<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSaic: include/rosaic/communication/async_manager.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSaic
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_25c9660b5b5a3198a5e6d7e5c352cd64.html">rosaic</a></li><li class="navelem"><a class="el" href="dir_5bcc204dec6afc863ccc0bfd1d0cc55d.html">communication</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">async_manager.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="async__manager_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Â© Copyright 2020, Septentrio NV/SA.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// All rights reserved.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// Redistribution and use in source and binary forms, with or without</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">// modification, are permitted provided that the following conditions are met:</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//    1. Redistributions of source code must retain the above copyright</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//       notice, this list of conditions and the following disclaimer.</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//    2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//       notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//       documentation and/or other materials provided with the distribution.</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//    3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">//       contributors may be used to endorse or promote products derived</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">//       from this software without specific prior written permission.</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE </span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR </span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF </span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) </span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment">// POSSIBILITY OF SUCH DAMAGE. </span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment">// Boost Software License - Version 1.0 - August 17th, 2003</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment">// </span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment">// Permission is hereby granted, free of charge, to any person or organization</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// obtaining a copy of the software and accompanying documentation covered by</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// this license (the &quot;Software&quot;) to use, reproduce, display, distribute,</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// execute, and transmit the Software, and to prepare derivative works of the</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// Software, and to permit third-parties to whom the Software is furnished to</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// do so, all subject to the following:</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">// The copyright notices in the Software and this entire statement, including</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// the above license grant, this restriction and the following disclaimer,</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment">// must be included in all copies of the Software, in whole or in part, and</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment">// all derivative works of the Software, unless such copies or derivative</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">// works are solely in the form of machine-executable object code generated by</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">// a source language processor.</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment">// </span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment">// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">// DEALINGS IN THE SOFTWARE.</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">// *****************************************************************************</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#include &lt;boost/thread.hpp&gt;</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment">// Boost&#39;s thread enables the use of multiple threads of execution with shared data in portable C++ code. It provides classes and functions for managing the threads themselves, along with others for synchronizing data between the threads or providing separate copies of data specific to individual threads. </span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="preprocessor">#include &lt;boost/thread/condition.hpp&gt;</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="preprocessor">#include &lt;boost/algorithm/string/join.hpp&gt;</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#include &lt;boost/asio.hpp&gt;</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="preprocessor">#include &lt;boost/function.hpp&gt;</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="preprocessor">#include &lt;boost/system/error_code.hpp&gt;</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor">#ifndef ASYNC_MANAGER_HPP</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="preprocessor">#define ASYNC_MANAGER_HPP</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno"><a class="line" href="namespaceio__comm__mosaic.html">   77</a></span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceio__comm__mosaic.html">io_comm_mosaic</a> </div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{</div><div class="line"><a name="l00083"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_manager.html">   83</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classio__comm__mosaic_1_1_manager.html">Manager</a> {</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keyword">public</span>:</div><div class="line"><a name="l00085"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">   85</a></span>&#160;            <span class="keyword">typedef</span> boost::function&lt;void(uint8_t*, std::size_t&amp;)&gt; <a class="code" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a>;</div><div class="line"><a name="l00086"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_manager.html#a8e9e2d5349b016bdc3d6f3e218490948">   86</a></span>&#160;            <span class="keyword">virtual</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a8e9e2d5349b016bdc3d6f3e218490948">~Manager</a>() {}</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;            <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a289befc7ff53ec05fd086d410a7607f9">setCallback</a>(<span class="keyword">const</span> Callback&amp; callback) = 0;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;         </div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            <span class="comment">// virtual void setRawDataCallback(const Callback&amp; callback) = 0; //later for MeasEpoch3, if we get that far..</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;         </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="comment">// virtual bool send(const uint8_t* data, const unsigned int size) = 0; // for sending data to Rx</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;           </div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a421341c8ed5d82a26170a389a34285f4">wait</a>(<span class="keyword">const</span> boost::posix_time::time_duration&amp; timeout) = 0;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;         </div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a7436618a129bd07735bb85e75fbdef7c">isOpen</a>() <span class="keyword">const</span> = 0;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    };</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00106"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html">  106</a></span>&#160;    <span class="keyword">class </span><a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a> : <span class="keyword">public</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html">Manager</a> </div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        <span class="keyword">public</span>:</div><div class="line"><a name="l00118"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">  118</a></span>&#160;            <span class="keyword">typedef</span> boost::mutex <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">Mutex</a>;</div><div class="line"><a name="l00124"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">  124</a></span>&#160;            <span class="keyword">typedef</span> boost::mutex::scoped_lock <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a>;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            </div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a>(boost::shared_ptr&lt;StreamT&gt; stream,</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                   boost::shared_ptr&lt;boost::asio::io_service&gt; io_service,</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                   std::size_t buffer_size = 8192);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            <span class="keyword">virtual</span> ~<a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a>();</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;     </div><div class="line"><a name="l00136"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a9fdc9e6bbdef18654b84c9864ae5e89a">  136</a></span>&#160;            <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a9fdc9e6bbdef18654b84c9864ae5e89a">setCallback</a>(<span class="keyword">const</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a>&amp; callback) { read_callback_ = callback; }</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;     </div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            <span class="comment">// void setRawDataCallback(const Callback&amp; callback) { write_callback_ = callback; }</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;     </div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;            <span class="comment">// bool send(const uint8_t* data, const unsigned int size);</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_manager.html#a421341c8ed5d82a26170a389a34285f4">wait</a>(<span class="keyword">const</span> boost::posix_time::time_duration&amp; timeout);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;     </div><div class="line"><a name="l00143"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a6140127a44ab250548d7e856b0987d1b">  143</a></span>&#160;            <span class="keywordtype">bool</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6140127a44ab250548d7e856b0987d1b">isOpen</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> stream_-&gt;is_open(); }</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;     </div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        <span class="keyword">protected</span>:</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            </div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keywordtype">void</span> doRead();</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;            </div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            <span class="keywordtype">void</span> async_read_some_handler(<span class="keyword">const</span> boost::system::error_code&amp;, std::size_t);</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;     </div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            <span class="comment">// void doWrite();</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;     </div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            <span class="keywordtype">void</span> doClose();</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;            </div><div class="line"><a name="l00159"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">  159</a></span>&#160;            boost::shared_ptr&lt;StreamT&gt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>; </div><div class="line"><a name="l00161"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">  161</a></span>&#160;            boost::shared_ptr&lt;boost::asio::io_service&gt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>; </div><div class="line"><a name="l00163"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">  163</a></span>&#160;            Mutex <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a>; </div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;            </div><div class="line"><a name="l00173"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">  173</a></span>&#160;            boost::condition <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">read_condition_</a>;</div><div class="line"><a name="l00174"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">  174</a></span>&#160;            std::vector&lt;uint8_t&gt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>; </div><div class="line"><a name="l00176"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">  176</a></span>&#160;            std::size_t <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a>;  </div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;            <span class="comment">// Mutex write_mutex_; </span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;            <span class="comment">// boost::condition write_condition_;</span></div><div class="line"><a name="l00179"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">  179</a></span>&#160;            std::vector&lt;uint8_t&gt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">out_</a>; </div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;     </div><div class="line"><a name="l00181"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#af6b39cc5f35fa2de241f0ad9de63c415">  181</a></span>&#160;            boost::shared_ptr&lt;boost::thread&gt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#af6b39cc5f35fa2de241f0ad9de63c415">callback_thread_</a>; </div><div class="line"><a name="l00182"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">  182</a></span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a>; </div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;            <span class="comment">// Callback write_callback_; </span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;     </div><div class="line"><a name="l00185"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">  185</a></span>&#160;            <span class="keywordtype">bool</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a>; </div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    };</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;     </div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00189"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">  189</a></span>&#160;    <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">AsyncManager&lt;StreamT&gt;::AsyncManager</a>(boost::shared_ptr&lt;StreamT&gt; stream,</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;             boost::shared_ptr&lt;boost::asio::io_service&gt; io_service,</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;             std::size_t buffer_size) : stopping_(false) <span class="comment">// Since buffer_size = 8912 in declaration, no need in definition any more (even yields error message, since &quot;overwrite&quot;).</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    {</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Setting the stream private variable of the AsyncManager class.&quot;</span>);</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a> = stream;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a> = io_service;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.resize(buffer_size);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a> = 0;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">out_</a>.reserve(buffer_size);  <span class="comment">// Note that std::vector::reserve() requests to reserve vector capacity be at least enough to contain n elements. </span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                                    <span class="comment">// Reallocation happens if there is need of even more space.</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;         </div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="comment">// This function is used to ask the io_service to execute the given handler, but without allowing the io_service to call the handler from inside this function.</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="comment">// The function signature of the handler must be: void handler(); </span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        <span class="comment">// The io_service guarantees that the handler (given as parameter) will only be called in a thread in which the run(), run_one(), poll() or poll_one() member functions is currently being invoked. </span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="comment">// So the fundamental difference is that dispatch will execute the work right away if it can and queue it otherwise while post queues the work no matter what.</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#af6b39cc5f35fa2de241f0ad9de63c415">callback_thread_</a>.reset(<span class="keyword">new</span> boost::thread(boost::bind(&amp;boost::asio::io_service::run, <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>))); <span class="comment">// io_service_ is already pointer</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="comment">// If the value of the pointer for the current thread is changed using reset(), then the previous value is destroyed by calling the cleanup routine. Alternatively, the stored value can be reset to NULL and the prior value returned by calling the release() member function, allowing the application to take back responsibility for destroying the object. </span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;     </div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00212"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#aae6a43b4bb2c627c98416f5416ac4780">  212</a></span>&#160;    <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aae6a43b4bb2c627c98416f5416ac4780">AsyncManager&lt;StreamT&gt;::~AsyncManager</a>() </div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    {</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager&lt;StreamT&gt;::doClose</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#af6b39cc5f35fa2de241f0ad9de63c415">callback_thread_</a>-&gt;join(); </div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="comment">//io_service_-&gt;reset(); </span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="comment">// Reset the io_service in preparation for a subsequent run() invocation. </span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="comment">// must be called prior to any second or later set of invocations of the run(), run_one() etc.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="comment">// After a call to reset(), the io_service object&#39;s stopped() function will return false. (true only after true stop)</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;    }</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;     </div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    <span class="comment">/*</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment">    template &lt;typename StreamT&gt;</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment">    bool AsyncManager&lt;StreamT&gt;::send(const uint8_t* data,</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment">                                     const unsigned int size) {</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment">        ScopedLock lock(write_mutex_);</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment">        if(size == 0) {</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">            ROS_ERROR(&quot;mosaic-X5 AsyncManager::send: Size of message to send is 0&quot;);</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">            return true;</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">        }</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">        if (out_.capacity() - out_.size() &lt; size) {// Returns the size of the storage space currently allocated for the vector, expressed in terms of elements.</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment">        // size vs capacity of vector: Size: the number of items currently in the vector Capacity: how many items can be fit in the vector before it is &quot;full&quot;. Once full, adding new items will result in a new, larger block of memory being allocated and the existing items being copied to it</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">            ROS_ERROR(&quot;mosaic-X5 AsyncManager::send: Output buffer too full to send message&quot;);</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment">            return false;</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment">        }</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">        out_.insert(out_.end(), data, data + size);</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">        // vector_name.insert (position, val) vs vector_name.insert(position, size, val) vs vector_name.insert(position, iterator1, iterator2)</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment">        // all three return an iterator which points to the newly inserted element. </span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment">        io_service_-&gt;post(boost::bind(&amp;AsyncManager&lt;StreamT&gt;::doWrite, this));</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment">        return true;</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment">    }</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment">    template &lt;typename StreamT&gt;</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment">    void AsyncManager&lt;StreamT&gt;::doWrite() {</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment">        ScopedLock lock(write_mutex_);</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment">        // Do nothing if out buffer is empty</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">        if (out_.size() == 0) {</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment">            return;</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment">        }</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment">        // Write all the data in the out buffer</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment">        boost::asio::write(*stream_, boost::asio::buffer(out_.data(), out_.size()));</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment">        //  The boost::asio::buffer function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment">        // POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment">        // A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. </span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment">        // A tuple of the form {void*, size_t} specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form {const void*, size_t} specifies a const (non-modifiable) region of memory. These two forms [typedef std::pair&lt;void*, std::size_t&gt; mutable_buffer; typedef std::pair&lt;const void*, std::size_t&gt; const_buffer;] correspond to the classes mutable_buffer and const_buffer, respectively. To mirror C++&#39;s conversion rules, a mutable_buffer is implicitly convertible to a const_buffer, and the opposite conversion is not permitted. </span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment">        // Also, An individual buffer may be created from a builtin array, std::vector, std::array or !boost::array of POD elements!, char d1[128]; size_t bytes_transferred = sock.receive(boost::asio::buffer(d1));</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment">        // write(SyncWriteStream&amp; s, const ConstBufferSequence&amp; buffers,    typename enable_if&lt;is_const_buffer_sequence&lt;ConstBufferSequence&gt;::value&gt;::type* = 0), so stream needs to satisfy certain rules</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment">        if (debug &gt;= 2) {</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment">            // Print the data that was sent</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment">            std::ostringstream oss;</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment">            for (std::vector&lt;uint8_t&gt;::iterator it = out_.begin();</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">                it != out_.end(); ++it)</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">                    oss &lt;&lt; boost::format(&quot;%02x&quot;) % static_cast&lt;unsigned int&gt;(*it) &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">            ROS_DEBUG(&quot;mosaic-X5 sent %li bytes: \n%s&quot;, out_.size(), oss.str().c_str());</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">        }</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment">        // Clear the buffer &amp; unlock</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">        out_.clear(); // clear() function is used to remove all the elements of the vector container, thus making it size 0.</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">        write_condition_.notify_all(); // Change the state of all threads waiting on *this to ready. If there are no waiting threads, notify_all() has no effect.</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">    }</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">    */</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00278"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">  278</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">AsyncManager&lt;StreamT&gt;::doRead</a>() {</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="comment">//ROS_DEBUG(&quot;Entered doRead() method of the AsyncManager class.&quot;);</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a> lock(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a>);</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>-&gt;async_read_some(</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;           boost::asio::buffer(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.data() + <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a>,</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                               <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.size() - <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a>),</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;                               boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager&lt;StreamT&gt;::async_read_some_handler</a>, <span class="keyword">this</span>,</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;                                   boost::asio::placeholders::error,</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;                                   boost::asio::placeholders::bytes_transferred));</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                                    <span class="comment">// handler is async_read_some_handler!!, call postponed as with post..</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;        <span class="comment">//ROS_DEBUG(&quot;After async_read_some command.&quot;);</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;     </div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00292"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">  292</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">AsyncManager&lt;StreamT&gt;::async_read_some_handler</a>(<span class="keyword">const</span> boost::system::error_code&amp; error,</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                                        std::size_t bytes_transfered) </div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    {</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="comment">//ROS_DEBUG(&quot;Entered async_read_some_handler method.&quot;);</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a> lock(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a>);</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keywordflow">if</span> (error) <span class="comment">//e.g. if no input received from receiver (or ttyACM1 !while! messages sent), bytes_transferred will be 0 of course, error.message() will be &quot;operation canceled&quot;</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            ROS_ERROR(<span class="stringliteral">&quot;mosaic-X5 ASIO input buffer read error: %s, %li&quot;</span>,</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                    error.message().c_str(), bytes_transfered); <span class="comment">// c_str() is also part of &lt;string&gt;, str() would not work here</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        } </div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_transfered &gt; 0) </div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a> += bytes_transfered;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;     </div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            <span class="comment">/* uint8_t *pRawDataStart = &amp;(*(in_.begin() + (in_buffer_size_ - bytes_transfered))); //&amp;(*()) seems redundant!</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">            std::size_t raw_data_stream_size = bytes_transfered;</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">            if (write_callback_) //bit confusing, write? only from new incoming data. Yes, raw data, nothing to do with doWrite!!</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">                write_callback_(pRawDataStart, raw_data_stream_size);</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment">            if (debug &gt;= 4) {</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment">                std::ostringstream oss;</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment">                for (std::vector&lt;uint8_t&gt;::iterator it =</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment">                    in_.begin() + in_buffer_size_ - bytes_transfered;</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="comment">                it != in_.begin() + in_buffer_size_; ++it) //Without curly braces, only the first statement following the loop definition is considered to belong to the loop body.</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="comment">                    oss &lt;&lt; boost::format(&quot;%02x&quot;) % static_cast&lt;unsigned int&gt;(*it) &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="comment">                ROS_DEBUG(&quot;mosaic-X5 received %li bytes \n%s&quot;, bytes_transfered,</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="comment">                    oss.str().c_str());</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="comment">            }*/</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;     </div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a>) <span class="comment">//will be false in InitializeSerial (first call)</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;            {</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                <span class="comment">//ROS_DEBUG(&quot;Before read_callback_(in_.data etc&quot;);</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a>(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.data(), <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">in_buffer_size_</a>);     <span class="comment">// not just the few bytes above, now all that was read in so far is passed to readCallback from CallbackHandlers class!..</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                                                                <span class="comment">// .data() Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="comment">//ROS_DEBUG(&quot;After read_callback_(in_.data etc&quot;);</span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;            }        </div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">read_condition_</a>.notify_all(); <span class="comment">//other threads can now read too..</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;        }</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;     </div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a>)</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Leaving async_read_some_handler method, with bytes_transferred being %u&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) bytes_transfered);</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    }</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;     </div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00338"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a43954630fb704f5e4fdc115710f8acef">  338</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a43954630fb704f5e4fdc115710f8acef">AsyncManager&lt;StreamT&gt;::doClose</a>() </div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;    {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a> lock(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a>);</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        boost::system::error_code error;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>-&gt;close(error); </div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;        <span class="keywordflow">if</span>(error)</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        {</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;            ROS_ERROR_STREAM(<span class="stringliteral">&quot;Error while closing the AsyncManager: &quot;</span> &lt;&lt; error.message().c_str());</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;        }</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    }</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;     </div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> StreamT&gt;</div><div class="line"><a name="l00351"></a><span class="lineno"><a class="line" href="classio__comm__mosaic_1_1_async_manager.html#a8efcf6f384b50825bdd7781f9e45614b">  351</a></span>&#160;    <span class="keywordtype">void</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a8efcf6f384b50825bdd7781f9e45614b">AsyncManager&lt;StreamT&gt;::wait</a>(<span class="keyword">const</span> boost::posix_time::time_duration&amp; timeout) </div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    {</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a> lock(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a>);</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">read_condition_</a>.timed_wait(lock, timeout);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="comment">// bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;        <span class="comment">// Unlocks mutex and blocks current thread for specified time. The thread will unblock when notified by a call to this-&gt;notify_one() (perhaps) or this-&gt;notify_all(), when the time as reported by boost::get_system_time() would be equal to or later than the specified abs_time, or spuriously.</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;        <span class="comment">// When the thread is unblocked (for whatever reason), the lock is reacquired by invoking (invoked under the hood, not you) lock.lock() before the call to wait returns (as in std::condition_variable::wait_for).</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        <span class="comment">// false if the call is returning because the time specified by abs_time was reached (kind of means waiting should be continued), true otherwise. </span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;}</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160; </div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="preprocessor">#endif // for ASYNC_MANAGER_HPP</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160; </div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160; </div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160; </div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aa01665c97d0868ddc8d6332638167f21"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">io_comm_mosaic::AsyncManager::doRead</a></div><div class="ttdeci">void doRead()</div><div class="ttdoc">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00278">async_manager.hpp:278</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a8efcf6f384b50825bdd7781f9e45614b"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a8efcf6f384b50825bdd7781f9e45614b">io_comm_mosaic::AsyncManager::wait</a></div><div class="ttdeci">void wait(const boost::posix_time::time_duration &amp;timeout)</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00351">async_manager.hpp:351</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a58e83fffb3b2fa12e0f7a66f28bb07a6"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">io_comm_mosaic::AsyncManager::Mutex</a></div><div class="ttdeci">boost::mutex Mutex</div><div class="ttdoc">Multithreaded programs use mutexes for synchronization. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00118">async_manager.hpp:118</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_af6b39cc5f35fa2de241f0ad9de63c415"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#af6b39cc5f35fa2de241f0ad9de63c415">io_comm_mosaic::AsyncManager::callback_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; callback_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a459077c21e975d157bd2d051b0363348"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">io_comm_mosaic::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00185">async_manager.hpp:185</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a49854b94a51b5eff105ede7afacf7e28"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">io_comm_mosaic::AsyncManager::out_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; out_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00179">async_manager.hpp:179</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ad31124eb014726b96f2753a93451a70f"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">io_comm_mosaic::AsyncManager::read_mutex_</a></div><div class="ttdeci">Mutex read_mutex_</div><div class="ttdoc">As name suggest, the read mutex. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00163">async_manager.hpp:163</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a86422ba2fce7002ba7aaa8184fecf931"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_comm_mosaic::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00161">async_manager.hpp:161</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a982365c42d5ea333850ad8ae01dea971"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">io_comm_mosaic::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00174">async_manager.hpp:174</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a19287f7b21a0d1c477f971c7bca8d4bb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">io_comm_mosaic::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00182">async_manager.hpp:182</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ab5bded7fc39a9751b92f8dcb45d98e07"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">io_comm_mosaic::AsyncManager::async_read_some_handler</a></div><div class="ttdeci">void async_read_some_handler(const boost::system::error_code &amp;, std::size_t)</div><div class="ttdoc">Handler for async_read_some (Boost library).. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00292">async_manager.hpp:292</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aae6a43b4bb2c627c98416f5416ac4780"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aae6a43b4bb2c627c98416f5416ac4780">io_comm_mosaic::AsyncManager::~AsyncManager</a></div><div class="ttdeci">virtual ~AsyncManager()</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00212">async_manager.hpp:212</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html_a421341c8ed5d82a26170a389a34285f4"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html#a421341c8ed5d82a26170a389a34285f4">io_comm_mosaic::Manager::wait</a></div><div class="ttdeci">virtual void wait(const boost::posix_time::time_duration &amp;timeout)=0</div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ac7e0e44e2fd0da547d05a7f3cf6d8ff0"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">io_comm_mosaic::AsyncManager::read_condition_</a></div><div class="ttdeci">boost::condition read_condition_</div><div class="ttdoc">A condition object is always used in conjunction with a mutex object (an object whose type is a model...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00173">async_manager.hpp:173</a></div></div>
<div class="ttc" id="namespaceio__comm__mosaic_html"><div class="ttname"><a href="namespaceio__comm__mosaic.html">io_comm_mosaic</a></div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00077">async_manager.hpp:77</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html">io_comm_mosaic::Manager</a></div><div class="ttdoc">Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00083">async_manager.hpp:83</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html_a8e9e2d5349b016bdc3d6f3e218490948"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html#a8e9e2d5349b016bdc3d6f3e218490948">io_comm_mosaic::Manager::~Manager</a></div><div class="ttdeci">virtual ~Manager()</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00086">async_manager.hpp:86</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a9fdc9e6bbdef18654b84c9864ae5e89a"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a9fdc9e6bbdef18654b84c9864ae5e89a">io_comm_mosaic::AsyncManager::setCallback</a></div><div class="ttdeci">void setCallback(const Callback &amp;callback)</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00136">async_manager.hpp:136</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a6140127a44ab250548d7e856b0987d1b"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a6140127a44ab250548d7e856b0987d1b">io_comm_mosaic::AsyncManager::isOpen</a></div><div class="ttdeci">bool isOpen() const</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00143">async_manager.hpp:143</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a6af0b2bc94ed4fbb2d6ba4aeef99f5e2"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">io_comm_mosaic::AsyncManager::AsyncManager</a></div><div class="ttdeci">AsyncManager(boost::shared_ptr&lt; StreamT &gt; stream, boost::shared_ptr&lt; boost::asio::io_service &gt; io_service, std::size_t buffer_size=8192)</div><div class="ttdoc">Class constructor. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00189">async_manager.hpp:189</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html_a04713eda3b65a6c34818941bd63b7402"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">io_comm_mosaic::Manager::Callback</a></div><div class="ttdeci">boost::function&lt; void(uint8_t *, std::size_t &amp;)&gt; Callback</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00085">async_manager.hpp:85</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a></div><div class="ttdoc">This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operat...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00106">async_manager.hpp:106</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html_a289befc7ff53ec05fd086d410a7607f9"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html#a289befc7ff53ec05fd086d410a7607f9">io_comm_mosaic::Manager::setCallback</a></div><div class="ttdeci">virtual void setCallback(const Callback &amp;callback)=0</div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a064c1bcb1d8c474b873026bd51c08fb3"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">io_comm_mosaic::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00159">async_manager.hpp:159</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a6586653c408e255140f553f4c0aa2e6e"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">io_comm_mosaic::AsyncManager::ScopedLock</a></div><div class="ttdeci">boost::mutex::scoped_lock ScopedLock</div><div class="ttdoc">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (re...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00124">async_manager.hpp:124</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a8f1bf55416a80bfb5dd7691b402aa448"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a8f1bf55416a80bfb5dd7691b402aa448">io_comm_mosaic::AsyncManager::in_buffer_size_</a></div><div class="ttdeci">std::size_t in_buffer_size_</div><div class="ttdoc">Keeps track of how large the buffer (not just space allocated) is at the moment. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00176">async_manager.hpp:176</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_manager_html_a7436618a129bd07735bb85e75fbdef7c"><div class="ttname"><a href="classio__comm__mosaic_1_1_manager.html#a7436618a129bd07735bb85e75fbdef7c">io_comm_mosaic::Manager::isOpen</a></div><div class="ttdeci">virtual bool isOpen() const =0</div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a43954630fb704f5e4fdc115710f8acef"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a43954630fb704f5e4fdc115710f8acef">io_comm_mosaic::AsyncManager::doClose</a></div><div class="ttdeci">void doClose()</div><div class="ttdoc">Closes Stream &quot;stream_&quot;. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00338">async_manager.hpp:338</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 30 2020 17:44:30 for ROSaic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
