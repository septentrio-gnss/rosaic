<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MinROS: AsyncManager&lt; StreamT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MinROS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AsyncManager&lt; StreamT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operations such as reading messages and sending commands..  
 <a href="class_async_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_async_manager__inherit__graph.png" border="0" usemap="#_async_manager_3_01_stream_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="_async_manager_3_01_stream_t_01_4_inherit__map" id="_async_manager_3_01_stream_t_01_4_inherit__map">
<area shape="rect" id="node2" href="class_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="61,5,133,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_async_manager__coll__graph.png" border="0" usemap="#_async_manager_3_01_stream_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_async_manager_3_01_stream_t_01_4_coll__map" id="_async_manager_3_01_stream_t_01_4_coll__map">
<area shape="rect" id="node2" href="class_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="215,5,287,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a95f37a8837c1baab18bb0e59a5097620"><td class="memItemLeft" align="right" valign="top">typedef boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a95f37a8837c1baab18bb0e59a5097620">Mutex</a></td></tr>
<tr class="memdesc:a95f37a8837c1baab18bb0e59a5097620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multithreaded programs use mutexes for synchronization.  <a href="#a95f37a8837c1baab18bb0e59a5097620">More...</a><br /></td></tr>
<tr class="separator:a95f37a8837c1baab18bb0e59a5097620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3445e89ad7e4ef71bc78dfc9502a5b"><td class="memItemLeft" align="right" valign="top">typedef boost::mutex::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a></td></tr>
<tr class="memdesc:a3e3445e89ad7e4ef71bc78dfc9502a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the mutex  <a href="#a3e3445e89ad7e4ef71bc78dfc9502a5b">More...</a><br /></td></tr>
<tr class="separator:a3e3445e89ad7e4ef71bc78dfc9502a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_manager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_manager.html">Manager</a></td></tr>
<tr class="memitem:a898018e1b33572176f1f76e34d4719c9 inherit pub_types_class_manager"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; void(uint8_t *, std::size_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_manager.html#a898018e1b33572176f1f76e34d4719c9">Callback</a></td></tr>
<tr class="separator:a898018e1b33572176f1f76e34d4719c9 inherit pub_types_class_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a565c4851dfbce4cef01153d1e8803569"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a565c4851dfbce4cef01153d1e8803569">AsyncManager</a> (boost::shared_ptr&lt; StreamT &gt; stream, boost::shared_ptr&lt; boost::asio::io_service &gt; io_service, std::size_t buffer_size=8192)</td></tr>
<tr class="memdesc:a565c4851dfbce4cef01153d1e8803569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#a565c4851dfbce4cef01153d1e8803569">More...</a><br /></td></tr>
<tr class="separator:a565c4851dfbce4cef01153d1e8803569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e02a66b100a64de57458e35571d6978"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a2e02a66b100a64de57458e35571d6978">~AsyncManager</a> ()</td></tr>
<tr class="separator:a2e02a66b100a64de57458e35571d6978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64d9f8f1af7cbaa18e816c15e12e8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a9a64d9f8f1af7cbaa18e816c15e12e8f">setCallback</a> (const <a class="el" href="class_manager.html#a898018e1b33572176f1f76e34d4719c9">Callback</a> &amp;callback)</td></tr>
<tr class="separator:a9a64d9f8f1af7cbaa18e816c15e12e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89dd0d154a7b547ef72e786b5ea7ef95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a89dd0d154a7b547ef72e786b5ea7ef95">wait</a> (const boost::posix_time::time_duration &amp;timeout)</td></tr>
<tr class="separator:a89dd0d154a7b547ef72e786b5ea7ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd275db0dbeb5942bae98a82d0e80f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a17dd275db0dbeb5942bae98a82d0e80f">isOpen</a> () const</td></tr>
<tr class="separator:a17dd275db0dbeb5942bae98a82d0e80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_manager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_manager.html">Manager</a></td></tr>
<tr class="memitem:a3dbc694b640c70009c5e0dec515d692c inherit pub_methods_class_manager"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_manager.html#a3dbc694b640c70009c5e0dec515d692c">~Manager</a> ()</td></tr>
<tr class="separator:a3dbc694b640c70009c5e0dec515d692c inherit pub_methods_class_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad91955c05eb32beba50890008d5629d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#ad91955c05eb32beba50890008d5629d9">doRead</a> ()</td></tr>
<tr class="separator:ad91955c05eb32beba50890008d5629d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dc13ee077bbd3852edfd610260cac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a33dc13ee077bbd3852edfd610260cac5">async_read_some_handler</a> (const boost::system::error_code &amp;, std::size_t)</td></tr>
<tr class="separator:a33dc13ee077bbd3852edfd610260cac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d434a0f1d5daf8f6f3ca1d7fc908a4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a7d434a0f1d5daf8f6f3ca1d7fc908a4a">doClose</a> ()</td></tr>
<tr class="separator:a7d434a0f1d5daf8f6f3ca1d7fc908a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9abfbac2555357c191ba44c72a202f3d"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; StreamT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">stream_</a></td></tr>
<tr class="separator:a9abfbac2555357c191ba44c72a202f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ebdc6358598a050ea6156943caa7fb"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a></td></tr>
<tr class="separator:ab0ebdc6358598a050ea6156943caa7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523cace4c1f895649958cae76fdb9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_async_manager.html#a95f37a8837c1baab18bb0e59a5097620">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">read_mutex_</a></td></tr>
<tr class="separator:a8523cace4c1f895649958cae76fdb9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119421a821a606c03511563a1d446cd"><td class="memItemLeft" align="right" valign="top">boost::condition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a6119421a821a606c03511563a1d446cd">read_condition_</a></td></tr>
<tr class="memdesc:a6119421a821a606c03511563a1d446cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition object is always used in conjunction with a mutex object (an object whose type is a model of a Mutex or one of its refinements).  <a href="#a6119421a821a606c03511563a1d446cd">More...</a><br /></td></tr>
<tr class="separator:a6119421a821a606c03511563a1d446cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f98c1c4d1a99093930dff72e60201d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">in_</a></td></tr>
<tr class="separator:a9f98c1c4d1a99093930dff72e60201d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84177d15996070c6240c92536f5a2b3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a></td></tr>
<tr class="separator:ac84177d15996070c6240c92536f5a2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e96c8ba8befb1719af86c16f54834c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#a01e96c8ba8befb1719af86c16f54834c">out_</a></td></tr>
<tr class="separator:a01e96c8ba8befb1719af86c16f54834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25e9dcaaa6c26bd58bc036654a91900"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#ae25e9dcaaa6c26bd58bc036654a91900">background_thread_</a></td></tr>
<tr class="separator:ae25e9dcaaa6c26bd58bc036654a91900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0ef8f65b76258785dc1929876d62e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_manager.html#a898018e1b33572176f1f76e34d4719c9">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">read_callback_</a></td></tr>
<tr class="separator:acf0ef8f65b76258785dc1929876d62e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e88fb96d7e1f574bfcff9dcf6d81d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">stopping_</a></td></tr>
<tr class="separator:ad0e88fb96d7e1f574bfcff9dcf6d81d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StreamT&gt;<br />
class AsyncManager&lt; StreamT &gt;</h3>

<p>This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operations such as reading messages and sending commands.. </p>
<p>StreamT is either boost::asio::serial_port or boost::asio::tcp::ip </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00076">76</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a95f37a8837c1baab18bb0e59a5097620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f37a8837c1baab18bb0e59a5097620">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mutex <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="class_async_manager.html#a95f37a8837c1baab18bb0e59a5097620">Mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multithreaded programs use mutexes for synchronization. </p>
<p>Boost.Thread provides different mutex classes with boost::mutex being the simplest. The basic principle of a mutex is to prevent other threads from taking ownership while a particular thread owns (by calling lock()) the mutex. Once released, a different thread can take ownership. This causes threads to wait until the thread that owns the mutex has finished processing and releases its ownership of the mutex. E.g. Because std::cout is a global object shared by the threads, access must be synchronized. Helps to avoid data races (A data race occurs when all: a) two or more threads in a single process access the same memory location concurrently, and b) at least one of the accesses is for writing, and c)the threads are not using any exclusive locks to control their accesses to that memory.) and undefined behavior </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00088">88</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<a id="a3e3445e89ad7e4ef71bc78dfc9502a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3445e89ad7e4ef71bc78dfc9502a5b">&#9670;&nbsp;</a></span>ScopedLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mutex::scoped_lock <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the mutex </p>
<p>It is more robust than raw mutex, e.g. with traditional mutex, an exception may occur while your mutex is locked, and your call to unlock() may never be reached, even though you do not have any return statement between your call to lock() and your call to unlock(). </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00094">94</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a565c4851dfbce4cef01153d1e8803569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565c4851dfbce4cef01153d1e8803569">&#9670;&nbsp;</a></span>AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="class_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; StreamT &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>8192</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Whether TCP/IP or serial communication, either boost::asio::serial_port or boost::asio::tcp::ip </td></tr>
    <tr><td class="paramname">io_service</td><td>The io_context object. The io_context represents your program's link to the operating system's I/O services. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00153">153</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00145">AsyncManager&lt; StreamT &gt;::background_thread_</a>, <a class="el" href="async__manager_8hpp_source.html#l00138">AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00139">AsyncManager&lt; StreamT &gt;::in_buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00125">AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00143">AsyncManager&lt; StreamT &gt;::out_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00124">AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                                : <a class="code" href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">stopping_</a>(<span class="keyword">false</span>) <span class="comment">// if buffer_size = 8912 in declaration, no need in definition any more..</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;{</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <a class="code" href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">stream_</a> = stream;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <a class="code" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a> = io_service;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    <a class="code" href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">in_</a>.resize(buffer_size);</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <a class="code" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a> = 0;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <a class="code" href="class_async_manager.html#a01e96c8ba8befb1719af86c16f54834c">out_</a>.reserve(buffer_size); <span class="comment">// std::vector::reserve() requests to reserve vector capacity be at least enough to contain n elements. Reallocation happens if there is need of even more space.</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;     </div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;    <a class="code" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="class_async_manager.html">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    <span class="comment">// This function is used to ask the io_service to execute the given handler, but without allowing the io_service to call the handler from inside this function.</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="comment">// The function signature of the handler must be: void handler(); </span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    <span class="comment">// The io_service guarantees that the handler (given as parameter) will only be called in a thread in which the run(), run_one(), poll() or poll_one() member functions is currently being invoked. </span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <span class="comment">// So the fundamental difference is that dispatch will execute the work right away if it can and queue it otherwise while post queues the work no matter what.</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <a class="code" href="class_async_manager.html#ae25e9dcaaa6c26bd58bc036654a91900">background_thread_</a>.reset(<span class="keyword">new</span> boost::thread(</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        boost::bind(&amp;boost::asio::io_service::run, <a class="code" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a>))); <span class="comment">// io_service_ is already pointer</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="comment">// If the value of the pointer for the current thread is changed using reset(), then the previous value is destroyed by calling the cleanup routine. Alternatively, the stored value can be reset to NULL and the prior value returned by calling the release() member function, allowing the application to take back responsibility for destroying the object. </span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;}</div><div class="ttc" id="class_async_manager_html_ad0e88fb96d7e1f574bfcff9dcf6d81d9"><div class="ttname"><a href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00149">async_manager.hpp:149</a></div></div>
<div class="ttc" id="class_async_manager_html_ac84177d15996070c6240c92536f5a2b3"><div class="ttname"><a href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">AsyncManager::in_buffer_size_</a></div><div class="ttdeci">std::size_t in_buffer_size_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00139">async_manager.hpp:139</a></div></div>
<div class="ttc" id="class_async_manager_html_ab0ebdc6358598a050ea6156943caa7fb"><div class="ttname"><a href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00125">async_manager.hpp:125</a></div></div>
<div class="ttc" id="class_async_manager_html_a01e96c8ba8befb1719af86c16f54834c"><div class="ttname"><a href="class_async_manager.html#a01e96c8ba8befb1719af86c16f54834c">AsyncManager::out_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; out_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00143">async_manager.hpp:143</a></div></div>
<div class="ttc" id="class_async_manager_html_a9abfbac2555357c191ba44c72a202f3d"><div class="ttname"><a href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00124">async_manager.hpp:124</a></div></div>
<div class="ttc" id="class_async_manager_html"><div class="ttname"><a href="class_async_manager.html">AsyncManager</a></div><div class="ttdoc">This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operat...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00076">async_manager.hpp:76</a></div></div>
<div class="ttc" id="class_async_manager_html_a9f98c1c4d1a99093930dff72e60201d1"><div class="ttname"><a href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00138">async_manager.hpp:138</a></div></div>
<div class="ttc" id="class_async_manager_html_ae25e9dcaaa6c26bd58bc036654a91900"><div class="ttname"><a href="class_async_manager.html#ae25e9dcaaa6c26bd58bc036654a91900">AsyncManager::background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; background_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00145">async_manager.hpp:145</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e02a66b100a64de57458e35571d6978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e02a66b100a64de57458e35571d6978">&#9670;&nbsp;</a></span>~AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::~<a class="el" href="class_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00175">175</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00145">AsyncManager&lt; StreamT &gt;::background_thread_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00125">AsyncManager&lt; StreamT &gt;::io_service_</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;{</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <a class="code" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="class_async_manager.html">AsyncManager&lt;StreamT&gt;::doClose</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    <a class="code" href="class_async_manager.html#ae25e9dcaaa6c26bd58bc036654a91900">background_thread_</a>-&gt;join(); </div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">//io_service_-&gt;reset(); </span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="comment">// Reset the io_service in preparation for a subsequent run() invocation. </span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    <span class="comment">// must be called prior to any second or later set of invocations of the run(), run_one() etc.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="comment">// After a call to reset(), the io_service object&#39;s stopped() function will return false. (true only after true stop)</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div><div class="ttc" id="class_async_manager_html_ab0ebdc6358598a050ea6156943caa7fb"><div class="ttname"><a href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00125">async_manager.hpp:125</a></div></div>
<div class="ttc" id="class_async_manager_html"><div class="ttname"><a href="class_async_manager.html">AsyncManager</a></div><div class="ttdoc">This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operat...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00076">async_manager.hpp:76</a></div></div>
<div class="ttc" id="class_async_manager_html_ae25e9dcaaa6c26bd58bc036654a91900"><div class="ttname"><a href="class_async_manager.html#ae25e9dcaaa6c26bd58bc036654a91900">AsyncManager::background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; background_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00145">async_manager.hpp:145</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a33dc13ee077bbd3852edfd610260cac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dc13ee077bbd3852edfd610260cac5">&#9670;&nbsp;</a></span>async_read_some_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::async_read_some_handler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes_transfered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00253">253</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00138">AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00139">AsyncManager&lt; StreamT &gt;::in_buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00125">AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00146">AsyncManager&lt; StreamT &gt;::read_callback_</a>, <a class="el" href="async__manager_8hpp_source.html#l00137">AsyncManager&lt; StreamT &gt;::read_condition_</a>, <a class="el" href="async__manager_8hpp_source.html#l00127">AsyncManager&lt; StreamT &gt;::read_mutex_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00149">AsyncManager&lt; StreamT &gt;::stopping_</a>.</p>
<div class="fragment"><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                                                {</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    <a class="code" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a> lock(<a class="code" href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">read_mutex_</a>);</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    <span class="keywordflow">if</span> (error) </div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    {</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        ROS_ERROR(<span class="stringliteral">&quot;mosaic-X5 ASIO input buffer read error: %s, %li&quot;</span>,</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;                error.message().str(), bytes_transfered);</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    } </div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_transfered &gt; 0) </div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    {</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        <a class="code" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a> += bytes_transfered;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160; </div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="comment">/* uint8_t *pRawDataStart = &amp;(*(in_.begin() + (in_buffer_size_ - bytes_transfered))); //&amp;(*()) seems redundant!</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">        std::size_t raw_data_stream_size = bytes_transfered;</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"> </span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment">        if (write_callback_) //bit confusing, write? only from new incoming data. Yes, raw data, nothing to do with doWrite!!</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment">            write_callback_(pRawDataStart, raw_data_stream_size);</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment"> </span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment">        if (debug &gt;= 4) {</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment">            std::ostringstream oss;</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment">            for (std::vector&lt;uint8_t&gt;::iterator it =</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment">                in_.begin() + in_buffer_size_ - bytes_transfered;</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment">            it != in_.begin() + in_buffer_size_; ++it) //Without curly braces, only the first statement following the loop definition is considered to belong to the loop body.</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment">                oss &lt;&lt; boost::format(&quot;%02x&quot;) % static_cast&lt;unsigned int&gt;(*it) &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment">            ROS_DEBUG(&quot;mosaic-X5 received %li bytes \n%s&quot;, bytes_transfered,</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">                oss.str().c_str());</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment">        }*/</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160; </div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">read_callback_</a>)</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <a class="code" href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">read_callback_</a>(<a class="code" href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">in_</a>.data(), <a class="code" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a>); <span class="comment">// not just the few bytes above, now all that was read in so far is passed to readCallback from CallbackHandlers class!..</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;        <span class="comment">// .data() Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;     </div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;        <a class="code" href="class_async_manager.html#a6119421a821a606c03511563a1d446cd">read_condition_</a>.notify_all(); <span class="comment">//other threads can now read too..</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    }</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160; </div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">stopping_</a>)</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <a class="code" href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="class_async_manager.html">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;}</div><div class="ttc" id="class_async_manager_html_ad0e88fb96d7e1f574bfcff9dcf6d81d9"><div class="ttname"><a href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00149">async_manager.hpp:149</a></div></div>
<div class="ttc" id="class_async_manager_html_ac84177d15996070c6240c92536f5a2b3"><div class="ttname"><a href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">AsyncManager::in_buffer_size_</a></div><div class="ttdeci">std::size_t in_buffer_size_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00139">async_manager.hpp:139</a></div></div>
<div class="ttc" id="class_async_manager_html_a6119421a821a606c03511563a1d446cd"><div class="ttname"><a href="class_async_manager.html#a6119421a821a606c03511563a1d446cd">AsyncManager::read_condition_</a></div><div class="ttdeci">boost::condition read_condition_</div><div class="ttdoc">A condition object is always used in conjunction with a mutex object (an object whose type is a model...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00137">async_manager.hpp:137</a></div></div>
<div class="ttc" id="class_async_manager_html_ab0ebdc6358598a050ea6156943caa7fb"><div class="ttname"><a href="class_async_manager.html#ab0ebdc6358598a050ea6156943caa7fb">AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00125">async_manager.hpp:125</a></div></div>
<div class="ttc" id="class_async_manager_html_acf0ef8f65b76258785dc1929876d62e3"><div class="ttname"><a href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00146">async_manager.hpp:146</a></div></div>
<div class="ttc" id="class_async_manager_html"><div class="ttname"><a href="class_async_manager.html">AsyncManager</a></div><div class="ttdoc">This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operat...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00076">async_manager.hpp:76</a></div></div>
<div class="ttc" id="class_async_manager_html_a9f98c1c4d1a99093930dff72e60201d1"><div class="ttname"><a href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00138">async_manager.hpp:138</a></div></div>
<div class="ttc" id="class_async_manager_html_a8523cace4c1f895649958cae76fdb9c6"><div class="ttname"><a href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">AsyncManager::read_mutex_</a></div><div class="ttdeci">Mutex read_mutex_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00127">async_manager.hpp:127</a></div></div>
<div class="ttc" id="class_async_manager_html_a3e3445e89ad7e4ef71bc78dfc9502a5b"><div class="ttname"><a href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">AsyncManager::ScopedLock</a></div><div class="ttdeci">boost::mutex::scoped_lock ScopedLock</div><div class="ttdoc">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (re...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00094">async_manager.hpp:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d434a0f1d5daf8f6f3ca1d7fc908a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d434a0f1d5daf8f6f3ca1d7fc908a4a">&#9670;&nbsp;</a></span>doClose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::doClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00293">293</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00127">AsyncManager&lt; StreamT &gt;::read_mutex_</a>, <a class="el" href="async__manager_8hpp_source.html#l00149">AsyncManager&lt; StreamT &gt;::stopping_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00124">AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;{</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <a class="code" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a> lock(<a class="code" href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">read_mutex_</a>);</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <a class="code" href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">stopping_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    boost::system::error_code error;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <a class="code" href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">stream_</a>-&gt;close(error); </div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    <span class="keywordflow">if</span>(error)</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;        ROS_ERROR_STREAM(<span class="stringliteral">&quot;Error while closing the AsyncManager: &quot;</span> &lt;&lt; error.message());</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;    }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;}</div><div class="ttc" id="class_async_manager_html_ad0e88fb96d7e1f574bfcff9dcf6d81d9"><div class="ttname"><a href="class_async_manager.html#ad0e88fb96d7e1f574bfcff9dcf6d81d9">AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00149">async_manager.hpp:149</a></div></div>
<div class="ttc" id="class_async_manager_html_a9abfbac2555357c191ba44c72a202f3d"><div class="ttname"><a href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00124">async_manager.hpp:124</a></div></div>
<div class="ttc" id="class_async_manager_html_a8523cace4c1f895649958cae76fdb9c6"><div class="ttname"><a href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">AsyncManager::read_mutex_</a></div><div class="ttdeci">Mutex read_mutex_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00127">async_manager.hpp:127</a></div></div>
<div class="ttc" id="class_async_manager_html_a3e3445e89ad7e4ef71bc78dfc9502a5b"><div class="ttname"><a href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">AsyncManager::ScopedLock</a></div><div class="ttdeci">boost::mutex::scoped_lock ScopedLock</div><div class="ttdoc">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (re...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00094">async_manager.hpp:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad91955c05eb32beba50890008d5629d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91955c05eb32beba50890008d5629d9">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::doRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00241">241</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00138">AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00139">AsyncManager&lt; StreamT &gt;::in_buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00127">AsyncManager&lt; StreamT &gt;::read_mutex_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00124">AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;                                   {</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    <a class="code" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a> lock(<a class="code" href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">read_mutex_</a>);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <a class="code" href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">stream_</a>-&gt;async_read_some(</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;       boost::asio::buffer(<a class="code" href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">in_</a>.data() + <a class="code" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a>,</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                           <a class="code" href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">in_</a>.size() - <a class="code" href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">in_buffer_size_</a>),</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;                           boost::bind(&amp;<a class="code" href="class_async_manager.html">AsyncManager&lt;StreamT&gt;::async_read_some_handler</a>, <span class="keyword">this</span>,</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                               boost::asio::placeholders::error,</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;                               boost::asio::placeholders::bytes_transferred));</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;                                <span class="comment">// handler is async_read_some_handler!!, call postponed as with post..</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;}</div><div class="ttc" id="class_async_manager_html_ac84177d15996070c6240c92536f5a2b3"><div class="ttname"><a href="class_async_manager.html#ac84177d15996070c6240c92536f5a2b3">AsyncManager::in_buffer_size_</a></div><div class="ttdeci">std::size_t in_buffer_size_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00139">async_manager.hpp:139</a></div></div>
<div class="ttc" id="class_async_manager_html_a9abfbac2555357c191ba44c72a202f3d"><div class="ttname"><a href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00124">async_manager.hpp:124</a></div></div>
<div class="ttc" id="class_async_manager_html"><div class="ttname"><a href="class_async_manager.html">AsyncManager</a></div><div class="ttdoc">This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operat...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00076">async_manager.hpp:76</a></div></div>
<div class="ttc" id="class_async_manager_html_a9f98c1c4d1a99093930dff72e60201d1"><div class="ttname"><a href="class_async_manager.html#a9f98c1c4d1a99093930dff72e60201d1">AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00138">async_manager.hpp:138</a></div></div>
<div class="ttc" id="class_async_manager_html_a8523cace4c1f895649958cae76fdb9c6"><div class="ttname"><a href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">AsyncManager::read_mutex_</a></div><div class="ttdeci">Mutex read_mutex_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00127">async_manager.hpp:127</a></div></div>
<div class="ttc" id="class_async_manager_html_a3e3445e89ad7e4ef71bc78dfc9502a5b"><div class="ttname"><a href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">AsyncManager::ScopedLock</a></div><div class="ttdeci">boost::mutex::scoped_lock ScopedLock</div><div class="ttdoc">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (re...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00094">async_manager.hpp:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a17dd275db0dbeb5942bae98a82d0e80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd275db0dbeb5942bae98a82d0e80f">&#9670;&nbsp;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::isOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_manager.html#a4ca77a3a2d73a47a2251aaf908965c59">Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00113">113</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">stream_</a>-&gt;is_open(); }</div><div class="ttc" id="class_async_manager_html_a9abfbac2555357c191ba44c72a202f3d"><div class="ttname"><a href="class_async_manager.html#a9abfbac2555357c191ba44c72a202f3d">AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00124">async_manager.hpp:124</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a64d9f8f1af7cbaa18e816c15e12e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a64d9f8f1af7cbaa18e816c15e12e8f">&#9670;&nbsp;</a></span>setCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::setCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_manager.html#a898018e1b33572176f1f76e34d4719c9">Callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_manager.html#a281cc321ac0d9f3e32e63e8bad2ab7a3">Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00106">106</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="class_manager.html#aa7f79abaef53d70cc6993a6a51d2e9d5">Manager::wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;{ <a class="code" href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">read_callback_</a> = callback; }</div><div class="ttc" id="class_async_manager_html_acf0ef8f65b76258785dc1929876d62e3"><div class="ttname"><a href="class_async_manager.html#acf0ef8f65b76258785dc1929876d62e3">AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00146">async_manager.hpp:146</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_async_manager_a9a64d9f8f1af7cbaa18e816c15e12e8f_cgraph.png" border="0" usemap="#class_async_manager_a9a64d9f8f1af7cbaa18e816c15e12e8f_cgraph" alt=""/></div>
<map name="class_async_manager_a9a64d9f8f1af7cbaa18e816c15e12e8f_cgraph" id="class_async_manager_a9a64d9f8f1af7cbaa18e816c15e12e8f_cgraph">
<area shape="rect" id="node2" href="class_manager.html#aa7f79abaef53d70cc6993a6a51d2e9d5" title="Manager::wait" alt="" coords="240,5,344,32"/>
</map>
</div>

</div>
</div>
<a id="a89dd0d154a7b547ef72e786b5ea7ef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89dd0d154a7b547ef72e786b5ea7ef95">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">const boost::posix_time::time_duration &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_manager.html#aa7f79abaef53d70cc6993a6a51d2e9d5">Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00306">306</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00137">AsyncManager&lt; StreamT &gt;::read_condition_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00127">AsyncManager&lt; StreamT &gt;::read_mutex_</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;{</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <a class="code" href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">ScopedLock</a> lock(<a class="code" href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">read_mutex_</a>);</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;    <a class="code" href="class_async_manager.html#a6119421a821a606c03511563a1d446cd">read_condition_</a>.timed_wait(lock, timeout);</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    <span class="comment">// bool timed_wait(boost::unique_lock&lt;boost::mutex&gt;&amp; lock,boost::system_time const&amp; abs_time)</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="comment">// Unlocks mutex and blocks current thread for specified time. The thread will unblock when notified by a call to this-&gt;notify_one() (perhaps) or this-&gt;notify_all(), when the time as reported by boost::get_system_time() would be equal to or later than the specified abs_time, or spuriously.</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="comment">// When the thread is unblocked (for whatever reason), the lock is reacquired by invoking (invoked under the hood, not you) lock.lock() before the call to wait returns (as in std::condition_variable::wait_for).</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    <span class="comment">// false if the call is returning because the time specified by abs_time was reached (kind of means waiting should be continued), true otherwise. </span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;}</div><div class="ttc" id="class_async_manager_html_a6119421a821a606c03511563a1d446cd"><div class="ttname"><a href="class_async_manager.html#a6119421a821a606c03511563a1d446cd">AsyncManager::read_condition_</a></div><div class="ttdeci">boost::condition read_condition_</div><div class="ttdoc">A condition object is always used in conjunction with a mutex object (an object whose type is a model...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00137">async_manager.hpp:137</a></div></div>
<div class="ttc" id="class_async_manager_html_a8523cace4c1f895649958cae76fdb9c6"><div class="ttname"><a href="class_async_manager.html#a8523cace4c1f895649958cae76fdb9c6">AsyncManager::read_mutex_</a></div><div class="ttdeci">Mutex read_mutex_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00127">async_manager.hpp:127</a></div></div>
<div class="ttc" id="class_async_manager_html_a3e3445e89ad7e4ef71bc78dfc9502a5b"><div class="ttname"><a href="class_async_manager.html#a3e3445e89ad7e4ef71bc78dfc9502a5b">AsyncManager::ScopedLock</a></div><div class="ttdeci">boost::mutex::scoped_lock ScopedLock</div><div class="ttdoc">scoped_lock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (re...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00094">async_manager.hpp:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="ae25e9dcaaa6c26bd58bc036654a91900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25e9dcaaa6c26bd58bc036654a91900">&#9670;&nbsp;</a></span>background_thread_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::thread&gt; <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::background_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00145">145</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00175">AsyncManager&lt; StreamT &gt;::~AsyncManager()</a>.</p>

</div>
</div>
<a id="a9f98c1c4d1a99093930dff72e60201d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f98c1c4d1a99093930dff72e60201d1">&#9670;&nbsp;</a></span>in_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00138">138</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00241">AsyncManager&lt; StreamT &gt;::doRead()</a>.</p>

</div>
</div>
<a id="ac84177d15996070c6240c92536f5a2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84177d15996070c6240c92536f5a2b3">&#9670;&nbsp;</a></span>in_buffer_size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::in_buffer_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00139">139</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00241">AsyncManager&lt; StreamT &gt;::doRead()</a>.</p>

</div>
</div>
<a id="ab0ebdc6358598a050ea6156943caa7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ebdc6358598a050ea6156943caa7fb">&#9670;&nbsp;</a></span>io_service_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::asio::io_service&gt; <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::io_service_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00125">125</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00175">AsyncManager&lt; StreamT &gt;::~AsyncManager()</a>.</p>

</div>
</div>
<a id="a01e96c8ba8befb1719af86c16f54834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e96c8ba8befb1719af86c16f54834c">&#9670;&nbsp;</a></span>out_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::out_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00143">143</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>

</div>
</div>
<a id="acf0ef8f65b76258785dc1929876d62e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0ef8f65b76258785dc1929876d62e3">&#9670;&nbsp;</a></span>read_callback_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_manager.html#a898018e1b33572176f1f76e34d4719c9">Callback</a> <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::read_callback_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00146">146</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>.</p>

</div>
</div>
<a id="a6119421a821a606c03511563a1d446cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119421a821a606c03511563a1d446cd">&#9670;&nbsp;</a></span>read_condition_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::condition <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::read_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition object is always used in conjunction with a mutex object (an object whose type is a model of a Mutex or one of its refinements). </p>
<p>The mutex object must be locked prior to waiting on the condition, which is verified by passing a lock object (an object whose type is a model of Lock or one of its refinements) to the condition object's wait functions. Upon blocking on the condition object, the thread unlocks the mutex object. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00137">137</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00306">AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="a8523cace4c1f895649958cae76fdb9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8523cace4c1f895649958cae76fdb9c6">&#9670;&nbsp;</a></span>read_mutex_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_async_manager.html#a95f37a8837c1baab18bb0e59a5097620">Mutex</a> <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::read_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00127">127</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, <a class="el" href="async__manager_8hpp_source.html#l00293">AsyncManager&lt; StreamT &gt;::doClose()</a>, <a class="el" href="async__manager_8hpp_source.html#l00241">AsyncManager&lt; StreamT &gt;::doRead()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00306">AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="ad0e88fb96d7e1f574bfcff9dcf6d81d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e88fb96d7e1f574bfcff9dcf6d81d9">&#9670;&nbsp;</a></span>stopping_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::stopping_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00149">149</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00253">AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00293">AsyncManager&lt; StreamT &gt;::doClose()</a>.</p>

</div>
</div>
<a id="a9abfbac2555357c191ba44c72a202f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abfbac2555357c191ba44c72a202f3d">&#9670;&nbsp;</a></span>stream_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;StreamT&gt; <a class="el" href="class_async_manager.html">AsyncManager</a>&lt; StreamT &gt;::stream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00124">124</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00153">AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00293">AsyncManager&lt; StreamT &gt;::doClose()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00241">AsyncManager&lt; StreamT &gt;::doRead()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/MinROS/communication/<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 22 2020 21:46:55 for MinROS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
