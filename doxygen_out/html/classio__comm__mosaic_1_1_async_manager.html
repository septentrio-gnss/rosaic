<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ROSaic: io_comm_mosaic::AsyncManager&lt; StreamT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ROSaic
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceio__comm__mosaic.html">io_comm_mosaic</a></li><li class="navelem"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">io_comm_mosaic::AsyncManager&lt; StreamT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operations such as reading messages and sending commands..  
 <a href="classio__comm__mosaic_1_1_async_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for io_comm_mosaic::AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager__inherit__graph.png" border="0" usemap="#io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_inherit__map" id="io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="23,5,206,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for io_comm_mosaic::AsyncManager&lt; StreamT &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager__coll__graph.png" border="0" usemap="#io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_coll__map" id="io__comm__mosaic_1_1_async_manager_3_01_stream_t_01_4_coll__map">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_manager.html" title="Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike..." alt="" coords="172,5,355,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a58e83fffb3b2fa12e0f7a66f28bb07a6"><td class="memItemLeft" align="right" valign="top">typedef boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">Mutex</a></td></tr>
<tr class="memdesc:a58e83fffb3b2fa12e0f7a66f28bb07a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multithreaded programs use mutexes for synchronization.  <a href="#a58e83fffb3b2fa12e0f7a66f28bb07a6">More...</a><br /></td></tr>
<tr class="separator:a58e83fffb3b2fa12e0f7a66f28bb07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6586653c408e255140f553f4c0aa2e6e"><td class="memItemLeft" align="right" valign="top">typedef boost::mutex::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a></td></tr>
<tr class="memdesc:a6586653c408e255140f553f4c0aa2e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ScopedLock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the mutex.  <a href="#a6586653c408e255140f553f4c0aa2e6e">More...</a><br /></td></tr>
<tr class="separator:a6586653c408e255140f553f4c0aa2e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classio__comm__mosaic_1_1_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classio__comm__mosaic_1_1_manager')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classio__comm__mosaic_1_1_manager.html">io_comm_mosaic::Manager</a></td></tr>
<tr class="memitem:a04713eda3b65a6c34818941bd63b7402 inherit pub_types_classio__comm__mosaic_1_1_manager"><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; void(uint8_t *, std::size_t &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a></td></tr>
<tr class="separator:a04713eda3b65a6c34818941bd63b7402 inherit pub_types_classio__comm__mosaic_1_1_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6af0b2bc94ed4fbb2d6ba4aeef99f5e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">AsyncManager</a> (boost::shared_ptr&lt; StreamT &gt; stream, boost::shared_ptr&lt; boost::asio::io_service &gt; io_service, std::size_t buffer_size=8192)</td></tr>
<tr class="memdesc:a6af0b2bc94ed4fbb2d6ba4aeef99f5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor.  <a href="#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">More...</a><br /></td></tr>
<tr class="separator:a6af0b2bc94ed4fbb2d6ba4aeef99f5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6a43b4bb2c627c98416f5416ac4780"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#aae6a43b4bb2c627c98416f5416ac4780">~AsyncManager</a> ()</td></tr>
<tr class="separator:aae6a43b4bb2c627c98416f5416ac4780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdc9e6bbdef18654b84c9864ae5e89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a9fdc9e6bbdef18654b84c9864ae5e89a">setCallback</a> (const <a class="el" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a> &amp;callback)</td></tr>
<tr class="separator:a9fdc9e6bbdef18654b84c9864ae5e89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcba672df423de9c48cd6383c5e97bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf">wait</a> (uint16_t *count)</td></tr>
<tr class="separator:abcba672df423de9c48cd6383c5e97bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6140127a44ab250548d7e856b0987d1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a6140127a44ab250548d7e856b0987d1b">isOpen</a> () const</td></tr>
<tr class="separator:a6140127a44ab250548d7e856b0987d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classio__comm__mosaic_1_1_manager"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classio__comm__mosaic_1_1_manager')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classio__comm__mosaic_1_1_manager.html">io_comm_mosaic::Manager</a></td></tr>
<tr class="memitem:a8e9e2d5349b016bdc3d6f3e218490948 inherit pub_methods_classio__comm__mosaic_1_1_manager"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_manager.html#a8e9e2d5349b016bdc3d6f3e218490948">~Manager</a> ()</td></tr>
<tr class="separator:a8e9e2d5349b016bdc3d6f3e218490948 inherit pub_methods_classio__comm__mosaic_1_1_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa01665c97d0868ddc8d6332638167f21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">doRead</a> ()</td></tr>
<tr class="memdesc:aa01665c97d0868ddc8d6332638167f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read_some_handler.  <a href="#aa01665c97d0868ddc8d6332638167f21">More...</a><br /></td></tr>
<tr class="separator:aa01665c97d0868ddc8d6332638167f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bded7fc39a9751b92f8dcb45d98e07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">async_read_some_handler</a> (const boost::system::error_code &amp;, std::size_t)</td></tr>
<tr class="memdesc:ab5bded7fc39a9751b92f8dcb45d98e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for async_read_some (Boost library)..  <a href="#ab5bded7fc39a9751b92f8dcb45d98e07">More...</a><br /></td></tr>
<tr class="separator:ab5bded7fc39a9751b92f8dcb45d98e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43954630fb704f5e4fdc115710f8acef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a43954630fb704f5e4fdc115710f8acef">doClose</a> ()</td></tr>
<tr class="memdesc:a43954630fb704f5e4fdc115710f8acef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes Stream "stream_".  <a href="#a43954630fb704f5e4fdc115710f8acef">More...</a><br /></td></tr>
<tr class="separator:a43954630fb704f5e4fdc115710f8acef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5847e4bf08005664c41280afd25611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a6a5847e4bf08005664c41280afd25611">call_async_wait</a> (uint16_t *count)</td></tr>
<tr class="separator:a6a5847e4bf08005664c41280afd25611"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a064c1bcb1d8c474b873026bd51c08fb3"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; StreamT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a></td></tr>
<tr class="memdesc:a064c1bcb1d8c474b873026bd51c08fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream, represents either serial or TCP/IP connection.  <a href="#a064c1bcb1d8c474b873026bd51c08fb3">More...</a><br /></td></tr>
<tr class="separator:a064c1bcb1d8c474b873026bd51c08fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86422ba2fce7002ba7aaa8184fecf931"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a></td></tr>
<tr class="memdesc:a86422ba2fce7002ba7aaa8184fecf931"><td class="mdescLeft">&#160;</td><td class="mdescRight">io_context object  <a href="#a86422ba2fce7002ba7aaa8184fecf931">More...</a><br /></td></tr>
<tr class="separator:a86422ba2fce7002ba7aaa8184fecf931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31124eb014726b96f2753a93451a70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#ad31124eb014726b96f2753a93451a70f">read_mutex_</a></td></tr>
<tr class="memdesc:ad31124eb014726b96f2753a93451a70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">As name suggest, the read mutex.  <a href="#ad31124eb014726b96f2753a93451a70f">More...</a><br /></td></tr>
<tr class="separator:ad31124eb014726b96f2753a93451a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e0e44e2fd0da547d05a7f3cf6d8ff0"><td class="memItemLeft" align="right" valign="top">boost::condition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">read_condition_</a></td></tr>
<tr class="memdesc:ac7e0e44e2fd0da547d05a7f3cf6d8ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A condition object is always used in conjunction with a mutex object (an object whose type is a model of a Mutex or one of its refinements).  <a href="#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">More...</a><br /></td></tr>
<tr class="separator:ac7e0e44e2fd0da547d05a7f3cf6d8ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982365c42d5ea333850ad8ae01dea971"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a></td></tr>
<tr class="separator:a982365c42d5ea333850ad8ae01dea971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49854b94a51b5eff105ede7afacf7e28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">out_</a></td></tr>
<tr class="separator:a49854b94a51b5eff105ede7afacf7e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033f218271dd41dd28d62953c2e7c736"><td class="memItemLeft" align="right" valign="top">boost::shared_ptr&lt; boost::thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">async_background_thread_</a></td></tr>
<tr class="separator:a033f218271dd41dd28d62953c2e7c736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19287f7b21a0d1c477f971c7bca8d4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a></td></tr>
<tr class="separator:a19287f7b21a0d1c477f971c7bca8d4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459077c21e975d157bd2d051b0363348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a></td></tr>
<tr class="separator:a459077c21e975d157bd2d051b0363348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7903d4f76f6a8dc159c6791a3974a2a8"><td class="memItemLeft" align="right" valign="top">const std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">buffer_size_</a></td></tr>
<tr class="memdesc:a7903d4f76f6a8dc159c6791a3974a2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">In and out buffers' size.  <a href="#a7903d4f76f6a8dc159c6791a3974a2a8">More...</a><br /></td></tr>
<tr class="separator:a7903d4f76f6a8dc159c6791a3974a2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5fa054a1d277b1b292dd8cc406c0fb"><td class="memItemLeft" align="right" valign="top">boost::asio::deadline_timer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a></td></tr>
<tr class="separator:a4b5fa054a1d277b1b292dd8cc406c0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa744a9dad7c40ad59a216f299244d07f"><td class="memItemLeft" align="right" valign="top">const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">count_max_</a></td></tr>
<tr class="separator:aa744a9dad7c40ad59a216f299244d07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b242acc985309e8b0df6de396c08ab"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">do_read_count_</a></td></tr>
<tr class="separator:ab4b242acc985309e8b0df6de396c08ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename StreamT&gt;<br />
class io_comm_mosaic::AsyncManager&lt; StreamT &gt;</h3>

<p>This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operations such as reading messages and sending commands.. </p>
<p>StreamT is either boost::asio::serial_port or boost::asio::tcp::ip </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00107">107</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a58e83fffb3b2fa12e0f7a66f28bb07a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e83fffb3b2fa12e0f7a66f28bb07a6">&#9670;&nbsp;</a></span>Mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mutex <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">Mutex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multithreaded programs use mutexes for synchronization. </p>
<p>Boost.Thread provides different mutex classes with boost::mutex being the simplest. The basic principle of a mutex is to prevent other threads from taking ownership while a particular thread owns (by calling lock()) the mutex. Once released, a different thread can take ownership. This causes threads to wait until the thread that owns the mutex has finished processing and releases its ownership of the mutex. E.g. Because std::cout is a global object shared by the threads, access must be synchronized (could also be done via boost::asio::io_context::strand). Helps to avoid data races (A data race occurs when all: a) two or more threads in a single process access the same memory location concurrently, and b) at least one of the accesses is for writing, and c)the threads are not using any exclusive locks to control their accesses to that memory.) and undefined behavior </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00119">119</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<a id="a6586653c408e255140f553f4c0aa2e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6586653c408e255140f553f4c0aa2e6e">&#9670;&nbsp;</a></span>ScopedLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::mutex::scoped_lock <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a6586653c408e255140f553f4c0aa2e6e">ScopedLock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ScopedLock is meant to carry out the tasks for locking, unlocking, try-locking and timed-locking (recursive or not) for the mutex. </p>
<p>It is more robust than a raw mutex: E.g. with a traditional mutex, an exception may occur while your mutex is locked, and your call to unlock() may never be reached, even though you do not have any return statement between your call to lock() and your call to unlock(). </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00125">125</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6af0b2bc94ed4fbb2d6ba4aeef99f5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2">&#9670;&nbsp;</a></span>AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::<a class="el" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramtype">boost::shared_ptr&lt; StreamT &gt;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; boost::asio::io_service &gt;&#160;</td>
          <td class="paramname"><em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>8192</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Whether TCP/IP or serial communication, either boost::asio::serial_port or boost::asio::tcp::ip </td></tr>
    <tr><td class="paramname">io_service</td><td>The io_context object. The io_context represents your program's link to the operating system's I/O services. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00204">204</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00180">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>, <a class="el" href="async__manager_8hpp_source.html#l00187">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00198">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::call_async_wait()</a>, <a class="el" href="async__manager_8hpp_source.html#l00194">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::do_read_count_</a>, <a class="el" href="async__manager_8hpp_source.html#l00173">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00160">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00178">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::out_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00158">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;                                    : <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a>(*(io_service.get()), boost::posix_time::seconds(1)), <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a>(<span class="keyword">false</span>), <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">buffer_size_</a>(buffer_size), <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">count_max_</a>(5) <span class="comment">// Since buffer_size = 8912 in declaration, no need in definition any more (even yields error message, since &quot;overwrite&quot;).</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;    {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Setting the stream private variable of the AsyncManager class.&quot;</span>);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">do_read_count_</a> = 0;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a> = stream;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a> = io_service;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.resize(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">buffer_size_</a>);</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">out_</a>.reserve(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">buffer_size_</a>);     <span class="comment">// Note that std::vector::reserve() requests to reserve vector capacity be at least enough to contain n elements. </span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                                    <span class="comment">// Reallocation happens if there is need of even more space.</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;         </div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        <span class="comment">// This function is used to ask the io_service to execute the given handler, but without allowing the io_service to call the handler from inside this function.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;        <span class="comment">// The function signature of the handler must be: void handler(); </span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="comment">// The io_service guarantees that the handler (given as parameter) will only be called in a thread in which the run(), run_one(), poll() or poll_one() member functions is currently being invoked. </span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        <span class="comment">// So the fundamental difference is that dispatch will execute the work right away if it can and queue it otherwise while post queues the work no matter what.</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">async_background_thread_</a>.reset(<span class="keyword">new</span> boost::thread(boost::bind(&amp;boost::asio::io_service::run, <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>))); <span class="comment">// io_service_ is already pointer</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        uint16_t count = 0;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        boost::thread(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a6a5847e4bf08005664c41280afd25611">AsyncManager::call_async_wait</a>, <span class="keyword">this</span>, &amp;count));</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="comment">// If the value of the pointer for the current thread is changed using reset(), then the previous value is destroyed by calling the cleanup routine. Alternatively, the stored value can be reset to NULL and the prior value returned by calling the release() member function, allowing the application to take back responsibility for destroying the object. </span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    } <span class="comment">// Calls std::terminate() on last thread created</span></div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aa01665c97d0868ddc8d6332638167f21"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">io_comm_mosaic::AsyncManager::doRead</a></div><div class="ttdeci">void doRead()</div><div class="ttdoc">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00295">async_manager.hpp:295</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a459077c21e975d157bd2d051b0363348"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">io_comm_mosaic::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a49854b94a51b5eff105ede7afacf7e28"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a49854b94a51b5eff105ede7afacf7e28">io_comm_mosaic::AsyncManager::out_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; out_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00178">async_manager.hpp:178</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a86422ba2fce7002ba7aaa8184fecf931"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_comm_mosaic::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00160">async_manager.hpp:160</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a982365c42d5ea333850ad8ae01dea971"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">io_comm_mosaic::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00173">async_manager.hpp:173</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a6a5847e4bf08005664c41280afd25611"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a6a5847e4bf08005664c41280afd25611">io_comm_mosaic::AsyncManager::call_async_wait</a></div><div class="ttdeci">void call_async_wait(uint16_t *count)</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00198">async_manager.hpp:198</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a4b5fa054a1d277b1b292dd8cc406c0fb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">io_comm_mosaic::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00189">async_manager.hpp:189</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a7903d4f76f6a8dc159c6791a3974a2a8"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">io_comm_mosaic::AsyncManager::buffer_size_</a></div><div class="ttdeci">const std::size_t buffer_size_</div><div class="ttdoc">In and out buffers&amp;#39; size. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00187">async_manager.hpp:187</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a033f218271dd41dd28d62953c2e7c736"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">io_comm_mosaic::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00180">async_manager.hpp:180</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ab4b242acc985309e8b0df6de396c08ab"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">io_comm_mosaic::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00194">async_manager.hpp:194</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a064c1bcb1d8c474b873026bd51c08fb3"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">io_comm_mosaic::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00158">async_manager.hpp:158</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aa744a9dad7c40ad59a216f299244d07f"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">io_comm_mosaic::AsyncManager::count_max_</a></div><div class="ttdeci">const uint16_t count_max_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00190">async_manager.hpp:190</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager_a6af0b2bc94ed4fbb2d6ba4aeef99f5e2_cgraph.png" border="0" usemap="#classio__comm__mosaic_1_1_async_manager_a6af0b2bc94ed4fbb2d6ba4aeef99f5e2_cgraph" alt=""/></div>
<map name="classio__comm__mosaic_1_1_async_manager_a6af0b2bc94ed4fbb2d6ba4aeef99f5e2_cgraph" id="classio__comm__mosaic_1_1_async_manager_a6af0b2bc94ed4fbb2d6ba4aeef99f5e2_cgraph">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_async_manager.html#a6a5847e4bf08005664c41280afd25611" title="io_comm_mosaic::AsyncManager\l::call_async_wait" alt="" coords="272,5,491,47"/>
<area shape="rect" id="node3" href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf" title="io_comm_mosaic::AsyncManager\l::wait" alt="" coords="539,5,757,47"/>
</map>
</div>

</div>
</div>
<a id="aae6a43b4bb2c627c98416f5416ac4780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6a43b4bb2c627c98416f5416ac4780">&#9670;&nbsp;</a></span>~AsyncManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::~<a class="el" href="classio__comm__mosaic_1_1_async_manager.html">AsyncManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00229">229</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00180">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>.</p>
<div class="fragment"><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="comment">//io_service_-&gt;post(boost::bind(&amp;AsyncManager&lt;StreamT&gt;::doClose, this));</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">async_background_thread_</a>-&gt;join(); </div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <span class="comment">//io_service_-&gt;reset(); </span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="comment">// Reset the io_service in preparation for a subsequent run() invocation. </span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        <span class="comment">// must be called prior to any second or later set of invocations of the run(), run_one() etc.</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="comment">// After a call to reset(), the io_service object&#39;s stopped() function will return false. (true only after true stop)</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a033f218271dd41dd28d62953c2e7c736"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">io_comm_mosaic::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00180">async_manager.hpp:180</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab5bded7fc39a9751b92f8dcb45d98e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bded7fc39a9751b92f8dcb45d98e07">&#9670;&nbsp;</a></span>async_read_some_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::async_read_some_handler </td>
          <td>(</td>
          <td class="paramtype">const boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bytes_transfered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handler for async_read_some (Boost library).. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00311">311</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00187">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::buffer_size_</a>, <a class="el" href="async__manager_8hpp_source.html#l00173">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::in_</a>, <a class="el" href="async__manager_8hpp_source.html#l00160">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::io_service_</a>, <a class="el" href="async__manager_8hpp_source.html#l00181">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::read_callback_</a>, <a class="el" href="async__manager_8hpp_source.html#l00172">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::read_condition_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00184">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::stopping_</a>.</p>
<div class="fragment"><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    {</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Entered async_read_some_handler method.&quot;</span>);</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        <span class="keywordflow">if</span> (error) <span class="comment">//e.g. if no input received from receiver (or ttyACM1 !while! messages sent), bytes_transferred will be 0 of course, error.message() will be &quot;operation canceled&quot;</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;        {</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            ROS_ERROR(<span class="stringliteral">&quot;mosaic-X5 ASIO input buffer read error: %s, %li&quot;</span>,</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    error.message().c_str(), bytes_transfered); <span class="comment">// c_str() is also part of &lt;string&gt;, str() would not work here</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        } </div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytes_transfered &gt; 0) </div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;        {</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;            <span class="comment">/* uint8_t *pRawDataStart = &amp;(*(in_.begin() + (in_buffer_size_ - bytes_transfered))); //&amp;(*()) seems redundant!</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="comment">            std::size_t raw_data_stream_size = bytes_transfered;</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="comment">            if (write_callback_) //bit confusing, write? only from new incoming data. Yes, raw data, nothing to do with doWrite!!</span></div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">                write_callback_(pRawDataStart, raw_data_stream_size);</span></div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">     </span></div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">            if (debug &gt;= 4) {</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">                std::ostringstream oss;</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment">                for (std::vector&lt;uint8_t&gt;::iterator it =</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">                    in_.begin() + in_buffer_size_ - bytes_transfered;</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment">                it != in_.begin() + in_buffer_size_; ++it) //Without curly braces, only the first statement following the loop definition is considered to belong to the loop body.</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment">                    oss &lt;&lt; boost::format(&quot;%02x&quot;) % static_cast&lt;unsigned int&gt;(*it) &lt;&lt; &quot; &quot;;</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment">                ROS_DEBUG(&quot;mosaic-X5 received %li bytes \n%s&quot;, bytes_transfered,</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment">                    oss.str().c_str());</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment">            }*/</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;     </div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;            <span class="keywordflow">if</span> (<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a>) <span class="comment">//Will be false in InitializeSerial (first call)</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;            {</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                <span class="comment">// start new thread, to be killed once read_callback_ returns...</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                <span class="comment">//temporary_thread new boost::thread(boost::bind(&amp;boost::asio::io_service::run, io_service_));</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                ROS_DEBUG(<span class="stringliteral">&quot;Leaving async_read_some_handler method and transfering to readCallback, with bytes_transferred being %u&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) bytes_transfered);</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                std::vector&lt;uint8_t&gt; copied_buffer = <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                <span class="comment">// Note that .data() returns a direct pointer to the memory array used internally by the vector to store its owned elements. Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                boost::thread temporary_thread(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a>, copied_buffer.data(), bytes_transfered);</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                temporary_thread.detach();</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                std::vector&lt;uint8_t&gt; empty;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a> = empty;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.resize(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">buffer_size_</a>);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;            }        </div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">read_condition_</a>.notify_all(); <span class="comment">//other threads can now read too..</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;        }</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;     </div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keywordflow">if</span> (!<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a>)</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_service_</a>-&gt;post(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">AsyncManager&lt;StreamT&gt;::doRead</a>, <span class="keyword">this</span>));</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aa01665c97d0868ddc8d6332638167f21"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aa01665c97d0868ddc8d6332638167f21">io_comm_mosaic::AsyncManager::doRead</a></div><div class="ttdeci">void doRead()</div><div class="ttdoc">Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00295">async_manager.hpp:295</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a459077c21e975d157bd2d051b0363348"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">io_comm_mosaic::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a86422ba2fce7002ba7aaa8184fecf931"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a86422ba2fce7002ba7aaa8184fecf931">io_comm_mosaic::AsyncManager::io_service_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::asio::io_service &gt; io_service_</div><div class="ttdoc">io_context object </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00160">async_manager.hpp:160</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a982365c42d5ea333850ad8ae01dea971"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">io_comm_mosaic::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00173">async_manager.hpp:173</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a19287f7b21a0d1c477f971c7bca8d4bb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">io_comm_mosaic::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ac7e0e44e2fd0da547d05a7f3cf6d8ff0"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">io_comm_mosaic::AsyncManager::read_condition_</a></div><div class="ttdeci">boost::condition read_condition_</div><div class="ttdoc">A condition object is always used in conjunction with a mutex object (an object whose type is a model...</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00172">async_manager.hpp:172</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a7903d4f76f6a8dc159c6791a3974a2a8"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a7903d4f76f6a8dc159c6791a3974a2a8">io_comm_mosaic::AsyncManager::buffer_size_</a></div><div class="ttdeci">const std::size_t buffer_size_</div><div class="ttdoc">In and out buffers&amp;#39; size. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00187">async_manager.hpp:187</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a5847e4bf08005664c41280afd25611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5847e4bf08005664c41280afd25611">&#9670;&nbsp;</a></span>call_async_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::call_async_wait </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00198">198</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00371">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a>.async_wait(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf">AsyncManager::wait</a>, <span class="keyword">this</span>, count));</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_abcba672df423de9c48cd6383c5e97bbf"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf">io_comm_mosaic::AsyncManager::wait</a></div><div class="ttdeci">void wait(uint16_t *count)</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00371">async_manager.hpp:371</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a4b5fa054a1d277b1b292dd8cc406c0fb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">io_comm_mosaic::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00189">async_manager.hpp:189</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_cgraph.png" border="0" usemap="#classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_cgraph" alt=""/></div>
<map name="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_cgraph" id="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_cgraph">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf" title="io_comm_mosaic::AsyncManager\l::wait" alt="" coords="272,5,491,47"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_icgraph.png" border="0" usemap="#classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_icgraph" alt=""/></div>
<map name="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_icgraph" id="classio__comm__mosaic_1_1_async_manager_a6a5847e4bf08005664c41280afd25611_icgraph">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2" title="Class constructor. " alt="" coords="272,5,491,47"/>
</map>
</div>

</div>
</div>
<a id="a43954630fb704f5e4fdc115710f8acef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43954630fb704f5e4fdc115710f8acef">&#9670;&nbsp;</a></span>doClose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::doClose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closes Stream "stream_". </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00359">359</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00184">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::stopping_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00158">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;    {</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">stopping_</a> = <span class="keyword">true</span>;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;        boost::system::error_code error;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>-&gt;close(error); </div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;        <span class="keywordflow">if</span>(error)</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        {</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            ROS_ERROR_STREAM(<span class="stringliteral">&quot;Error while closing the AsyncManager: &quot;</span> &lt;&lt; error.message().c_str());</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a459077c21e975d157bd2d051b0363348"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a459077c21e975d157bd2d051b0363348">io_comm_mosaic::AsyncManager::stopping_</a></div><div class="ttdeci">bool stopping_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00184">async_manager.hpp:184</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a064c1bcb1d8c474b873026bd51c08fb3"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">io_comm_mosaic::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00158">async_manager.hpp:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa01665c97d0868ddc8d6332638167f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01665c97d0868ddc8d6332638167f21">&#9670;&nbsp;</a></span>doRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::doRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read_some_handler. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00295">295</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00194">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::do_read_count_</a>, <a class="el" href="async__manager_8hpp_source.html#l00173">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::in_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00158">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::stream_</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    {</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Entered doRead() method of the AsyncManager class.&quot;</span>);</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="comment">//ScopedLock lock(read_mutex_); // lock will be destroyed when scope of doRead ends and the mutex released (hence need another lock in async_read_some_handler)</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>-&gt;async_read_some(</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;           boost::asio::buffer(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.data(),</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                               <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">in_</a>.size()),</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;                               boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">AsyncManager&lt;StreamT&gt;::async_read_some_handler</a>, <span class="keyword">this</span>,</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                                   boost::asio::placeholders::error,</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                                   boost::asio::placeholders::bytes_transferred));</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                                    <span class="comment">// handler is async_read_some_handler!!, call postponed as with post..</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        ++<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">do_read_count_</a>;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;        ROS_DEBUG(<span class="stringliteral">&quot;Leaving doRead.&quot;</span>);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a982365c42d5ea333850ad8ae01dea971"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a982365c42d5ea333850ad8ae01dea971">io_comm_mosaic::AsyncManager::in_</a></div><div class="ttdeci">std::vector&lt; uint8_t &gt; in_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00173">async_manager.hpp:173</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ab5bded7fc39a9751b92f8dcb45d98e07"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ab5bded7fc39a9751b92f8dcb45d98e07">io_comm_mosaic::AsyncManager::async_read_some_handler</a></div><div class="ttdeci">void async_read_some_handler(const boost::system::error_code &amp;, std::size_t)</div><div class="ttdoc">Handler for async_read_some (Boost library).. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00311">async_manager.hpp:311</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ab4b242acc985309e8b0df6de396c08ab"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">io_comm_mosaic::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00194">async_manager.hpp:194</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a064c1bcb1d8c474b873026bd51c08fb3"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">io_comm_mosaic::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00158">async_manager.hpp:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6140127a44ab250548d7e856b0987d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6140127a44ab250548d7e856b0987d1b">&#9670;&nbsp;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::isOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classio__comm__mosaic_1_1_manager.html#a7436618a129bd07735bb85e75fbdef7c">io_comm_mosaic::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00142">142</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">stream_</a>-&gt;is_open(); }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a064c1bcb1d8c474b873026bd51c08fb3"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a064c1bcb1d8c474b873026bd51c08fb3">io_comm_mosaic::AsyncManager::stream_</a></div><div class="ttdeci">boost::shared_ptr&lt; StreamT &gt; stream_</div><div class="ttdoc">Stream, represents either serial or TCP/IP connection. </div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00158">async_manager.hpp:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9fdc9e6bbdef18654b84c9864ae5e89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdc9e6bbdef18654b84c9864ae5e89a">&#9670;&nbsp;</a></span>setCallback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::setCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classio__comm__mosaic_1_1_manager.html#a289befc7ff53ec05fd086d410a7607f9">io_comm_mosaic::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00135">135</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="classio__comm__mosaic_1_1_manager.html#a2284309e5607c4216d9ca481a7b2cc01">io_comm_mosaic::Manager::wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;{ <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">read_callback_</a> = callback; }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a19287f7b21a0d1c477f971c7bca8d4bb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a19287f7b21a0d1c477f971c7bca8d4bb">io_comm_mosaic::AsyncManager::read_callback_</a></div><div class="ttdeci">Callback read_callback_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00181">async_manager.hpp:181</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager_a9fdc9e6bbdef18654b84c9864ae5e89a_cgraph.png" border="0" usemap="#classio__comm__mosaic_1_1_async_manager_a9fdc9e6bbdef18654b84c9864ae5e89a_cgraph" alt=""/></div>
<map name="classio__comm__mosaic_1_1_async_manager_a9fdc9e6bbdef18654b84c9864ae5e89a_cgraph" id="classio__comm__mosaic_1_1_async_manager_a9fdc9e6bbdef18654b84c9864ae5e89a_cgraph">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_manager.html#a2284309e5607c4216d9ca481a7b2cc01" title="io_comm_mosaic::Manager\l::wait" alt="" coords="272,5,455,47"/>
</map>
</div>

</div>
</div>
<a id="abcba672df423de9c48cd6383c5e97bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcba672df423de9c48cd6383c5e97bbf">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classio__comm__mosaic_1_1_manager.html#a2284309e5607c4216d9ca481a7b2cc01">io_comm_mosaic::Manager</a>.</p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00371">371</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">References <a class="el" href="async__manager_8hpp_source.html#l00180">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_background_thread_</a>, <a class="el" href="async__manager_8hpp_source.html#l00190">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::count_max_</a>, <a class="el" href="async__manager_8hpp_source.html#l00194">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::do_read_count_</a>, and <a class="el" href="async__manager_8hpp_source.html#l00189">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::timer_</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00198">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::call_async_wait()</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        <span class="keywordflow">if</span> (*count &lt; <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">count_max_</a>)</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        {</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;            ++(*count);</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a>.expires_at(<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a>.expires_at() + boost::posix_time::seconds(1));</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">timer_</a>.async_wait(boost::bind(&amp;<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf">AsyncManager::wait</a>, <span class="keyword">this</span>, count));</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        }</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        <span class="keywordflow">if</span> ((*count &gt;= <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">count_max_</a>) &amp;&amp; (<a class="code" href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">do_read_count_</a> &lt; 2))</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        {</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;            ROS_INFO(<span class="stringliteral">&quot;No incoming messages, driver stopped, ros::spin() will spin forever unless you hit Ctrl+C.&quot;</span>);</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;            <a class="code" href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">async_background_thread_</a>-&gt;interrupt(); </div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;        }</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    }</div><div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_abcba672df423de9c48cd6383c5e97bbf"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#abcba672df423de9c48cd6383c5e97bbf">io_comm_mosaic::AsyncManager::wait</a></div><div class="ttdeci">void wait(uint16_t *count)</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00371">async_manager.hpp:371</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a4b5fa054a1d277b1b292dd8cc406c0fb"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a4b5fa054a1d277b1b292dd8cc406c0fb">io_comm_mosaic::AsyncManager::timer_</a></div><div class="ttdeci">boost::asio::deadline_timer timer_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00189">async_manager.hpp:189</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_a033f218271dd41dd28d62953c2e7c736"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#a033f218271dd41dd28d62953c2e7c736">io_comm_mosaic::AsyncManager::async_background_thread_</a></div><div class="ttdeci">boost::shared_ptr&lt; boost::thread &gt; async_background_thread_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00180">async_manager.hpp:180</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_ab4b242acc985309e8b0df6de396c08ab"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#ab4b242acc985309e8b0df6de396c08ab">io_comm_mosaic::AsyncManager::do_read_count_</a></div><div class="ttdeci">uint16_t do_read_count_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00194">async_manager.hpp:194</a></div></div>
<div class="ttc" id="classio__comm__mosaic_1_1_async_manager_html_aa744a9dad7c40ad59a216f299244d07f"><div class="ttname"><a href="classio__comm__mosaic_1_1_async_manager.html#aa744a9dad7c40ad59a216f299244d07f">io_comm_mosaic::AsyncManager::count_max_</a></div><div class="ttdeci">const uint16_t count_max_</div><div class="ttdef"><b>Definition:</b> <a href="async__manager_8hpp_source.html#l00190">async_manager.hpp:190</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classio__comm__mosaic_1_1_async_manager_abcba672df423de9c48cd6383c5e97bbf_icgraph.png" border="0" usemap="#classio__comm__mosaic_1_1_async_manager_abcba672df423de9c48cd6383c5e97bbf_icgraph" alt=""/></div>
<map name="classio__comm__mosaic_1_1_async_manager_abcba672df423de9c48cd6383c5e97bbf_icgraph" id="classio__comm__mosaic_1_1_async_manager_abcba672df423de9c48cd6383c5e97bbf_icgraph">
<area shape="rect" id="node2" href="classio__comm__mosaic_1_1_async_manager.html#a6a5847e4bf08005664c41280afd25611" title="io_comm_mosaic::AsyncManager\l::call_async_wait" alt="" coords="272,5,491,47"/>
<area shape="rect" id="node3" href="classio__comm__mosaic_1_1_async_manager.html#a6af0b2bc94ed4fbb2d6ba4aeef99f5e2" title="Class constructor. " alt="" coords="539,5,757,47"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a033f218271dd41dd28d62953c2e7c736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033f218271dd41dd28d62953c2e7c736">&#9670;&nbsp;</a></span>async_background_thread_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::thread&gt; <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::async_background_thread_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00180">180</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00371">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::wait()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00229">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::~AsyncManager()</a>.</p>

</div>
</div>
<a id="a7903d4f76f6a8dc159c6791a3974a2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7903d4f76f6a8dc159c6791a3974a2a8">&#9670;&nbsp;</a></span>buffer_size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::size_t <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::buffer_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In and out buffers' size. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00187">187</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>

</div>
</div>
<a id="aa744a9dad7c40ad59a216f299244d07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa744a9dad7c40ad59a216f299244d07f">&#9670;&nbsp;</a></span>count_max_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::count_max_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00190">190</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00371">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="ab4b242acc985309e8b0df6de396c08ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b242acc985309e8b0df6de396c08ab">&#9670;&nbsp;</a></span>do_read_count_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::do_read_count_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00194">194</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00295">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::doRead()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00371">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<a id="a982365c42d5ea333850ad8ae01dea971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982365c42d5ea333850ad8ae01dea971">&#9670;&nbsp;</a></span>in_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::in_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00173">173</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00295">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::doRead()</a>.</p>

</div>
</div>
<a id="a86422ba2fce7002ba7aaa8184fecf931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86422ba2fce7002ba7aaa8184fecf931">&#9670;&nbsp;</a></span>io_service_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;boost::asio::io_service&gt; <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::io_service_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>io_context object </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00160">160</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>

</div>
</div>
<a id="a49854b94a51b5eff105ede7afacf7e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49854b94a51b5eff105ede7afacf7e28">&#9670;&nbsp;</a></span>out_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::out_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00178">178</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>.</p>

</div>
</div>
<a id="a19287f7b21a0d1c477f971c7bca8d4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19287f7b21a0d1c477f971c7bca8d4bb">&#9670;&nbsp;</a></span>read_callback_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__mosaic_1_1_manager.html#a04713eda3b65a6c34818941bd63b7402">Callback</a> <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::read_callback_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00181">181</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>.</p>

</div>
</div>
<a id="ac7e0e44e2fd0da547d05a7f3cf6d8ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e0e44e2fd0da547d05a7f3cf6d8ff0">&#9670;&nbsp;</a></span>read_condition_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::condition <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::read_condition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A condition object is always used in conjunction with a mutex object (an object whose type is a model of a Mutex or one of its refinements). </p>
<p>The mutex object must be locked prior to waiting on the condition, which is verified by passing a lock object (an object whose type is a model of Lock or one of its refinements) to the condition object's wait functions. Upon blocking on the condition object, the thread unlocks the mutex object. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00172">172</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>.</p>

</div>
</div>
<a id="ad31124eb014726b96f2753a93451a70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31124eb014726b96f2753a93451a70f">&#9670;&nbsp;</a></span>read_mutex_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classio__comm__mosaic_1_1_async_manager.html#a58e83fffb3b2fa12e0f7a66f28bb07a6">Mutex</a> <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::read_mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As name suggest, the read mutex. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00162">162</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

</div>
</div>
<a id="a459077c21e975d157bd2d051b0363348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459077c21e975d157bd2d051b0363348">&#9670;&nbsp;</a></span>stopping_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::stopping_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00184">184</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00311">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::async_read_some_handler()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00359">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::doClose()</a>.</p>

</div>
</div>
<a id="a064c1bcb1d8c474b873026bd51c08fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064c1bcb1d8c474b873026bd51c08fb3">&#9670;&nbsp;</a></span>stream_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::shared_ptr&lt;StreamT&gt; <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::stream_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream, represents either serial or TCP/IP connection. </p>

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00158">158</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00204">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::AsyncManager()</a>, <a class="el" href="async__manager_8hpp_source.html#l00359">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::doClose()</a>, and <a class="el" href="async__manager_8hpp_source.html#l00295">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::doRead()</a>.</p>

</div>
</div>
<a id="a4b5fa054a1d277b1b292dd8cc406c0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5fa054a1d277b1b292dd8cc406c0fb">&#9670;&nbsp;</a></span>timer_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::deadline_timer <a class="el" href="classio__comm__mosaic_1_1_async_manager.html">io_comm_mosaic::AsyncManager</a>&lt; StreamT &gt;::timer_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="async__manager_8hpp_source.html#l00189">189</a> of file <a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="async__manager_8hpp_source.html#l00371">io_comm_mosaic::AsyncManager&lt; StreamT &gt;::wait()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/rosaic/communication/<a class="el" href="async__manager_8hpp_source.html">async_manager.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 7 2020 13:57:28 for ROSaic by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
