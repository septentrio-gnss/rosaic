// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************

#ifndef CALLBACKHANDLERS_HPP
#define CALLBACKHANDLERS_HPP

// Boost includes
#include <boost/foreach.hpp> 
// In C++, writing a loop that iterates over a sequence is tedious --> BOOST_FOREACH(char ch, "Hello World")
#include <boost/function.hpp>
// E.g. boost::function<int(const char*)> f = std::atoi;defines a pointer f that can point to functions that expect a parameter of type const char* and return a value of type int
// Generally, any place in which a function pointer would be used to defer a call or make a callback, Boost.Function can be used instead to allow the user greater flexibility in the implementation of the target.
#include <boost/thread.hpp>
// Boost's thread enables the use of multiple threads of execution with shared data in portable C++ code. It provides classes and functions for managing the threads themselves, along with others for synchronizing data between the threads or providing separate copies of data specific to individual threads. 
#include <boost/thread/condition.hpp>
#include <boost/tokenizer.hpp>
// The tokenizer class provides a container view of a series of tokens contained in a sequence, e.g. if you are not interested in non-words...
#include <boost/algorithm/string/join.hpp>
// Join algorithm is a counterpart to split algorithms. It joins strings from a 'list' by adding user defined separator.
#include <boost/date_time/posix_time/posix_time.hpp>
// The class boost::posix_time::ptime that we will use defines a location-independent time. It uses the type boost::gregorian::date, yet also stores a time.
#include <boost/asio.hpp>
// Very important: Boost.Asio may be used to perform both synchronous and asynchronous operations on I/O objects such as sockets. 
#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <boost/asio/serial_port.hpp>
#include <boost/thread/mutex.hpp>

// Other includes
#include <MinROS/communication/mosaicMessage.hpp> 
#include <nmea_msgs/Gpgga.h>

/**
 * @file callbackhandlers.hpp
 * @date 22/08/20
 * @brief Handles callbacks when reading in various NMEA messages and/or SBF blocks
 */

namespace io_comm_mosaic 
{
	extern int debug;
	/**
	 * @class CallbackHandler
	 * @brief Abstract class representing a generic callback handler, top-level functionality such as wait
	 */
	class CallbackHandler {
		public:
			virtual void handle(mosaicMessage& mMessage) = 0;
	 
			bool wait(const boost::posix_time::time_duration& timeout) {
				boost::mutex::scoped_lock lock(mutex_);
				return condition_.timed_wait(lock, timeout);
			}
	 
		protected:
			boost::mutex mutex_; 
			boost::condition_variable condition_; 
	};
	 
	/**
	 * @class CallbackHandler_
	 * @brief Derived class operating on a mosaic message level
	 */
	template <typename T>
	class CallbackHandler_ : public CallbackHandler {
		public:
			typedef boost::function<void(const T&)> Callback; 
	 
			CallbackHandler_(const Callback& func = Callback()) : func_(func) {}
	   
			virtual const T& get() { return message_; }
	 
			void handle(mosaicMessage& mMessage) {
				boost::mutex::scoped_lock lock(mutex_);
				try 
				{
					//ROS_DEBUG("Attempting to read message");
					if (!mMessage.read<T>(message_)) 
					{
						ROS_DEBUG("Read apparently successful..");
						std::ostringstream ss;
						ss << "mosaic decoder error for message with ID " << mMessage.MessageID();
						ROS_DEBUG_COND(debug >= 2, "%s", ss.str().c_str());
						condition_.notify_all();
						return;
					}
				} catch (std::runtime_error& e) 
				{
					std::ostringstream ss;
					ss << "mosaic decoder error for message with ID " << mMessage.MessageID();
					ROS_DEBUG_COND(debug >= 2, "%s", ss.str().c_str());
					condition_.notify_all();
					return;
				}
	 
				if (func_) func_(message_); 
				condition_.notify_all();
			}
	   
		private:
			Callback func_; 
			T message_; 
	};
	 
	/**
	 * @class CallbackHandlers
	 * @brief Represents ensemble of messages, to be handled at once by this class
	 */
	 
	class CallbackHandlers {
		
		public:
	
			//! Key is std::string, value is boost::shared_ptr<CallbackHandler> 
			typedef std::multimap<std::string,
							 boost::shared_ptr<CallbackHandler> > Callbacks;
							 
			CallbackHandlers() = default;
			
			template <typename T> 
			//! Insert adds a pair to our multimap, with the message_ID being the key; this method is called by handlers_ in minros_node.cpp
			//! T would be e.g. PVTGeodetic struct, or nmea_msgs::Gpgga (which is not a struct, maybe internally?)..
			Callbacks insert(std::string message_ID, typename CallbackHandler_<T>::Callback callback) // typename is not needed here
			{
				boost::mutex::scoped_lock lock(callback_mutex_);
				CallbackHandler_<T>* handler = new CallbackHandler_<T>(callback); // Adding typename might be cleaner, but is optional again
				callbacks_.insert(std::make_pair(message_ID, boost::shared_ptr<CallbackHandler>(handler)));
				Callbacks::key_type key = "$GPGGA";
				//ROS_DEBUG("After insert command, key is there: %u", (unsigned int) callbacks_.count(key));
				return callbacks_;
			}
	 
			//! Called many many times (every time mMessage is found to contain some useful message), for loop can forward to message-specific handle if latter was added via callbacks_.insert at some earlier point
			void handle(mosaicMessage& mMessage) 
			{
				// !!Find!! the callback handler for the message & decode it
				boost::mutex::scoped_lock lock(callback_mutex_);
				Callbacks::key_type key = mMessage.MessageID();
				//ROS_DEBUG("The element exists in our map: %s", callbacks_.count(key) ? "true" : "false");
				//ROS_DEBUG("The element exists in our map: %u", (unsigned int) callbacks_.count(key));
				for (Callbacks::iterator callback = callbacks_.lower_bound(key); callback != callbacks_.upper_bound(key); ++callback)
				{
					//ROS_DEBUG("Inside for loop for calling specific message handle.");
					callback->second->handle(mMessage);
				}
			}
	 
			/**
			 * @brief Stores momentary (polling, not reading) message with ID "message_ID" in "message", after having waited for "timeout"
			 * 
			 * Needs to be checked!
			 * @param[out] message Storage for polled message
			 * @param[in] message_ID ID of mosaid message
			 * @param[in] timeout How much time should pass before storage is overwritten?
			 * @return 
			 */
			template <typename T>
			bool poll(T& message, std::string message_ID, const boost::posix_time::time_duration& timeout) {
				bool result = false;
				callback_mutex_.lock();
				CallbackHandler_<T>* handler = new CallbackHandler_<T>(); // this calls the constructor with empty function
				Callbacks::iterator callback = callbacks_.insert(std::make_pair(message_ID, boost::shared_ptr<CallbackHandler>(handler)));
				callback_mutex_.unlock();
	 
				// Wait for the message
				if (handler->wait(timeout)) {
					message = handler->get();
					result = true;
				}
		 
				// Remove the callback handler
				callback_mutex_.lock();
				callbacks_.erase(callback);
				callback_mutex_.unlock();
				return result;
			}
	 
			/**
			 * @brief Main callback organizer "on callbackhandlers' thread" (recall: this callback_thread is initialized upon InitializeSerial call)
			 * @param data Buffer passed on from AsyncManager class
			 */
			void readCallback(uint8_t* data, std::size_t& size) 
			{
				mosaicMessage mMessage(data, size);
				//ROS_DEBUG("Created mosaicMessage object");
				// Read !all! (there might be many) the messages in the buffer
				while (mMessage.search() != mMessage.end() && mMessage.found()) 
				{
					if (debug >= 3) 
					{
						// Print the received bytes (if NMEA) or just show messageID..
						if (mMessage.pos()[0] == SEP_SYNC_BYTE_1 && mMessage.pos()[1] == SEP_SYNC_BYTE_2)
						{
							ROS_DEBUG("Apparently we are dealing with an SBF block");
							unsigned long sbf_block_length;
							sbf_block_length = (unsigned long) mMessage.block_length(); //c-like cast notation, functional notation did not work, although https://www.cplusplus.com/doc/tutorial/typecasting/ suggests otherwise
							ROS_DEBUG("Driver reading SBF block %s with %lu bytes...", mMessage.MessageID().c_str(), sbf_block_length); //recall: long is at least 32 bits
						}
						else
						{
							std::ostringstream oss;
							boost::char_separator<char> sep("\r");
							typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
							std::size_t end_point = std::min(static_cast<std::size_t>(mMessage.end() - mMessage.pos()), static_cast<std::size_t>(82));
							std::string block_in_string(reinterpret_cast<const char*>(mMessage.pos()), end_point);	// Syntax: new_string_name (const char* s, size_t n); size_t is either 2 or 8 bytes, depending on your system
																													// NMEA 0183 messages are at most 82 characters long, , including the $ or ! starting character and the ending <LF>
							tokenizer tokens(block_in_string, sep);
							//ROS_DEBUG("block_in_string is ready to be iterated, first NMEA message should be %s", (*tokens.begin()).c_str());
						}
					}
	 
					//ROS_DEBUG("Handing over from readcallback to handle while count is %d", mMessage.get_count());
					handle(mMessage);
				}
	 
				// delete read bytes from input buffer
				std::copy(mMessage.pos(), mMessage.end(), data); //Recall: The first and second parameter specify the range of elements to copy, while the third parameter specifies the beginning of the destination range. 
				size -= mMessage.pos() - data; // data was never modified
			}
			
			//! Call back handlers for mosaic messages, needs to be public since we insert pairs to the multimap within Subscribe() method
			Callbacks callbacks_;
	 
		private:
			
			//! The "static" keyword resolves construct-by-copying issues related to this mutex by making it available throughout the code. 
			//! The mutex constructor list contains "mutex (const mutex&) = delete", hence construct-by-copying a mutex is explicitly prohibited.
			static boost::mutex callback_mutex_; 
			
	};
	
}


#endif 