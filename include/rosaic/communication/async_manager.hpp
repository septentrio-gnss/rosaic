// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************

// Boost includes
#include <boost/thread.hpp>
#include <boost/thread/condition.hpp>
#include <boost/algorithm/string/join.hpp>
#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/function.hpp>
#include <boost/system/error_code.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

#ifndef ASYNC_MANAGER_HPP
#define ASYNC_MANAGER_HPP

/**
 * @file async_manager.hpp
 * @date 20/08/20
 * @brief Implements asynchronous operations for an I/O manager such as reading NMEA messages or SBF blocks and sending commands to serial port or via TCP/IP
 */
 
namespace io_comm_mosaic 
{
	/**
	 * @class Manager
	 * @brief Interface (in C++ terms), that could be used for any I/O manager, synchronous and asynchronous alike
	 */
	class Manager {
		public:
			typedef boost::function<void(std::vector<uint8_t>, std::size_t&)> Callback;
			virtual ~Manager() {}
			virtual void SetCallback(const Callback& callback) = 0;
		 
			// virtual void SetRawDataCallback(const Callback& callback) = 0; //later for MeasEpoch3, if we get that far..
		 
			// virtual bool Send(const uint8_t* data, const unsigned int size) = 0; // for sending data to Rx
		   
			virtual void Wait(uint16_t* count) = 0;
		 
			virtual bool IsOpen() const = 0;
	};


	/**
	 * @class AsyncManager
	 * @brief This is the central interface between this ROS driver and the mosaic receiver(s), managing I/O operations such as reading messages and sending commands..
	 * 
	 * StreamT is either boost::asio::serial_port or boost::asio::tcp::ip
	 */
	template <typename StreamT>
	class AsyncManager : public Manager 
	{
		public:
			/**
			 * @brief Class constructor
			 * @param stream Whether TCP/IP or serial communication, either boost::asio::serial_port or boost::asio::tcp::ip
			 * @param io_service The io_context object. The io_context represents your program's link to the operating system's I/O services. 
			 */
			AsyncManager(boost::shared_ptr<StreamT> stream, boost::shared_ptr<boost::asio::io_service> io_service, std::size_t buffer_size = 8192);
			virtual ~AsyncManager();
	 
			void SetCallback(const Callback& callback) { read_callback_ = callback; }
	 
			// void SetRawDataCallback(const Callback& callback) { write_callback_ = callback; }
	 
			// bool Send(const uint8_t* data, const unsigned int size);
			void Wait(uint16_t* count);
	 
			bool IsOpen() const { return stream_->is_open(); }
	 
		protected:
			
			//! Reads in via async_read_some and hands certain number of bytes (bytes_transferred) over to async_read_some_handler 
			void DoRead();
			
			//!  Handler for async_read_some (Boost library)..
			void AsyncReadSomeHandler(const boost::system::error_code&, std::size_t);
	 
			// void DoWrite();
	 
			//! Closes Stream "stream_"
			void DoClose();
			
			//! Stream, represents either serial or TCP/IP connection
			boost::shared_ptr<StreamT> stream_; 
			//! io_context object
			boost::shared_ptr<boost::asio::io_service> io_service_; 
			
			std::vector<uint8_t> in_; 
			
			std::vector<uint8_t> out_; 
	 
			boost::shared_ptr<boost::thread> async_background_thread_; 
			Callback read_callback_; 
			
			// Callback write_callback_; 
	 
			bool stopping_; 
			
			/// In and out buffers' size
			const std::size_t buffer_size_;
			
			boost::asio::deadline_timer timer_;
			const uint16_t count_max_;
			
			void CallAsyncWait(uint16_t* count);
			
			uint16_t do_read_count_;
	};
	 
	template <typename StreamT>
	void AsyncManager<StreamT>::CallAsyncWait(uint16_t* count)
	{
		timer_.async_wait(boost::bind(&AsyncManager::Wait, this, count));
	}
	
	template <typename StreamT>
	AsyncManager<StreamT>::AsyncManager(boost::shared_ptr<StreamT> stream,
			 boost::shared_ptr<boost::asio::io_service> io_service,
			 std::size_t buffer_size) : timer_(*(io_service.get()), boost::posix_time::seconds(1)), stopping_(false), buffer_size_(buffer_size), count_max_(6) // Since buffer_size = 8912 in declaration, no need in definition any more (even yields error message, since "overwrite").
	{
		ROS_DEBUG("Setting the stream private variable of the AsyncManager class.");
		do_read_count_ = 0;
		stream_ = stream;
		io_service_ = io_service;
		in_.resize(buffer_size_);

		out_.reserve(buffer_size_); 	// Note that std::vector::reserve() requests to reserve vector capacity be at least enough to contain n elements. 
										// Reallocation happens if there is need of even more space.
		 
		io_service_->post(boost::bind(&AsyncManager<StreamT>::DoRead, this));
		// This function is used to ask the io_service to execute the given handler, but without allowing the io_service to call the handler from inside this function.
		// The function signature of the handler must be: void handler(); 
		// The io_service guarantees that the handler (given as parameter) will only be called in a thread in which the run(), run_one(), poll() or poll_
		// one() member functions is currently being invoked. 
		// So the fundamental difference is that dispatch will execute the work right away if it can and queue it otherwise while post queues the work no matter what.
		async_background_thread_.reset(new boost::thread(boost::bind(&boost::asio::io_service::run, io_service_))); // io_service_ is already pointer
		// If the value of the pointer for the current thread is changed using reset(), then the previous value is destroyed by calling the cleanup routine. 
		// Alternatively, the stored value can be reset to NULL and the prior value returned by calling the release() member function, 
		// allowing the application to take back responsibility for destroying the object. 
		uint16_t count = 0;
		boost::thread(boost::bind(&AsyncManager::CallAsyncWait, this, &count));
	} // Calls std::terminate() on thread just created
	 
	template <typename StreamT>
	AsyncManager<StreamT>::~AsyncManager() 
	{
		//io_service_->post(boost::bind(&AsyncManager<StreamT>::doClose, this));
		async_background_thread_->join(); 
		//io_service_->reset(); 
		// Reset the io_service in preparation for a subsequent run() invocation. 
		// It must be called prior to any second or later set of invocations of the run(), run_one() etc.
		// After a call to reset(), the io_service object's stopped() function will return false (true only after true stop).
	}

	template <typename StreamT>
	void AsyncManager<StreamT>::DoRead() 
	{
		stream_->async_read_some(
								boost::asio::buffer(in_.data(),
								in_.size()),
								boost::bind(&AsyncManager<StreamT>::AsyncReadSomeHandler, this,
								boost::asio::placeholders::error,
								boost::asio::placeholders::bytes_transferred));
								// The handler is async_read_some_handler, whose call is postponed to when async_read_some completes.
		++do_read_count_;
	}
	 
	template <typename StreamT>
	void AsyncManager<StreamT>::AsyncReadSomeHandler(const boost::system::error_code& error,
								std::size_t bytes_transfered) 
	{
		if (error) 
		{
			ROS_ERROR("mosaic ASIO input buffer read error: %s, %li",
					error.message().c_str(), bytes_transfered); // The c_str() method is also part of the <string> header.
		} 
		else if (bytes_transfered > 0) 
		{ 
			if (read_callback_) //Will be false in InitializeSerial (first call)
			{
				ROS_DEBUG("Launching ReadCallback thread, with bytes_transferred being %u", (unsigned int) bytes_transfered);
				std::vector<uint8_t> copied_buffer = in_;
				// Launch new thread, detached right afterwards..
				boost::thread temporary_thread(read_callback_, copied_buffer, bytes_transfered);
				temporary_thread.detach();
				std::vector<uint8_t> empty;
				in_ = empty;
				in_.resize(buffer_size_);
			}		 
		}
	 
		if (!stopping_)
			io_service_->post(boost::bind(&AsyncManager<StreamT>::DoRead, this));
	}
	 
	// Still needs to be tested.
	template <typename StreamT>
	void AsyncManager<StreamT>::DoClose() 
	{
		stopping_ = true;
		boost::system::error_code error;
		stream_->close(error); 
		if(error)
		{
			ROS_ERROR_STREAM("Error while closing the AsyncManager: " << error.message().c_str());
		}
	}
	 
	template <typename StreamT>
	void AsyncManager<StreamT>::Wait(uint16_t* count) //const boost::posix_time::time_duration& timeout) 
	{
		if (*count < count_max_)
		{
			++(*count);
			timer_.expires_at(timer_.expires_at() + boost::posix_time::seconds(1));
			if (!(*count == count_max_))
			{
				timer_.async_wait(boost::bind(&AsyncManager::Wait, this, count));
			}
		}
		if ((*count == count_max_) && (do_read_count_ < 3))	// Why 3? Even if there are no incoming messages, doRead() is called once. 
															// It will be called a second time in TCP/IP mode since (just example) "IP10<" is transmitted.
		{
			ROS_INFO("No incoming messages, driver stopped, ros::spin() will spin forever unless you hit Ctrl+C.");
			async_background_thread_->interrupt(); 
		}
	}
}
 
#endif // for ASYNC_MANAGER_HPP
 
 
 