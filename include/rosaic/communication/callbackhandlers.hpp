// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************

#ifndef CALLBACKHANDLERS_HPP
#define CALLBACKHANDLERS_HPP

// Boost includes
#include <boost/foreach.hpp> 
// In C++, writing a loop that iterates over a sequence is tedious --> BOOST_FOREACH(char ch, "Hello World")
#include <boost/function.hpp>
// E.g. boost::function<int(const char*)> f = std::atoi;defines a pointer f that can point to functions that expect a parameter of type const char* and return a value of type int
// Generally, any place in which a function pointer would be used to defer a call or make a callback, Boost.Function can be used instead to allow the user greater flexibility in the implementation of the target.
#include <boost/thread.hpp>
// Boost's thread enables the use of multiple threads of execution with shared data in portable C++ code. It provides classes and functions for managing the threads themselves, along with others for synchronizing data between the threads or providing separate copies of data specific to individual threads. 
#include <boost/thread/condition.hpp>
#include <boost/tokenizer.hpp>
// The tokenizer class provides a container view of a series of tokens contained in a sequence, e.g. if you are not interested in non-words...
#include <boost/algorithm/string/join.hpp>
// Join algorithm is a counterpart to split algorithms. It joins strings from a 'list' by adding user defined separator.
#include <boost/date_time/posix_time/posix_time.hpp>
// The class boost::posix_time::ptime that we will use defines a location-independent time. It uses the type boost::gregorian::date, yet also stores a time.
#include <boost/asio.hpp>
// Very important: Boost.Asio may be used to perform both synchronous and asynchronous operations on I/O objects such as sockets. 
#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <boost/asio/serial_port.hpp>
#include <boost/thread/mutex.hpp>

// ROSaic includes
#include <rosaic/communication/mosaicMessage.hpp>

/**
 * @file callbackhandlers.hpp
 * @date 22/08/20
 * @brief Handles callbacks when reading in various NMEA messages and/or SBF blocks
 */
 
extern bool publish_navsatfix;
extern bool publish_gpsfix;
extern bool publish_gpst;
extern bool publish_posewithcovariancestamped;
extern bool response_received;
extern boost::mutex response_mutex;
extern boost::condition_variable response_condition;
extern bool cd_received;
extern boost::mutex cd_mutex;
extern boost::condition_variable cd_condition;
extern uint32_t cd_count;
extern std::string mosaic_tcp_port;

namespace io_comm_mosaic 
{
	/**
	 * @class CallbackHandler
	 * @brief Abstract class representing a generic callback handler, includes high-level functionality such as wait
	 */
	class AbstractCallbackHandler 
	{
		public:
			virtual void Handle(mosaicMessage& mMessage, std::string message_key) = 0;
	 
			bool Wait(const boost::posix_time::time_duration& timeout) 
			{
				boost::mutex::scoped_lock lock(mutex_);
				return condition_.timed_wait(lock, timeout);
			}
	 
		protected:
			boost::mutex mutex_; 
			boost::condition_variable condition_; 
	};
	 
	/**
	 * @class CallbackHandler
	 * @brief Derived class operating on a ROS message level
	 */
	template <typename T>
	class CallbackHandler : public AbstractCallbackHandler 
	{
		public:
			typedef boost::function<void(const T&)> Callback; 
	 
			CallbackHandler(const Callback& func = Callback()) : func_(func) {}
	   
			virtual const T& Get() { return message_; }
	 
			void Handle(mosaicMessage& mMessage, std::string message_key) 
			{
				boost::mutex::scoped_lock lock(mutex_);
				try 
				{
					if (!mMessage.Read<T>(message_, message_key)) 
					{
						std::ostringstream ss;
						ss << "Read unsuccessful: mosaic decoder error for message with ID (empty field if non-determinable)" << mMessage.MessageID() << ". Reason unknown.";
						throw std::runtime_error(ss.str());
						ROS_INFO("%s", ss.str().c_str());
						return;
					}
				} catch (std::runtime_error& e) 
				{
					std::ostringstream ss;
					ss << "Read unsuccessful: mosaic decoder error for message with ID " << mMessage.MessageID() << ".\nReason: " << e.what();
					throw std::runtime_error(ss.str());
					ROS_INFO("%s", ss.str().c_str());
					return;
				}
				
				condition_.notify_all();
				if (func_) func_(message_); 
			}
	   
		private:
			Callback func_; 
			T message_; 
	};
	 
	/**
	 * @class CallbackHandlers
	 * @brief Represents ensemble of (to be constructed) ROS messages, to be handled at once by this class
	 */
	 
	class CallbackHandlers 
	{
		
		public:
	
			//! Key is std::string and represents the ROS message key, value is boost::shared_ptr<CallbackHandler> 
			typedef std::multimap<std::string, boost::shared_ptr<AbstractCallbackHandler>> CallbackMap;
			
			CallbackHandlers() = default;
			
			template <typename T> 
			//! Insert adds a pair to our multimap, with the message_ID being the key; this method is called by handlers_ in rosaic_node.cpp
			//! T would be a (custom or not) ROS message, e.g. rosaic::PVTGeodetic, or nmea_msgs::GPGGA
			CallbackMap Insert(std::string message_key, typename CallbackHandler<T>::Callback callback) // typename is not needed here
			{
				boost::mutex::scoped_lock lock(callback_mutex_);
				CallbackHandler<T>* handler = new CallbackHandler<T>(callback); // Adding typename might be cleaner, but is optional again
				callbackmap_.insert(std::make_pair(message_key, boost::shared_ptr<AbstractCallbackHandler>(handler)));
				CallbackMap::key_type key = message_key;
				ROS_DEBUG("Key successfully inserted to multimap: %s", ((unsigned int) callbackmap_.count(key)) ? "true" : "false");
				return callbackmap_;
			}
	 
			//! This method is called every time mMessage is found to contain some potentially useful message.
			//! The for loop forwards to a ROS message specific handle if the latter was added via callbackmap_.insert at some earlier point.
			void Handle(mosaicMessage& mMessage) 
			{
				// Find the ROS message callback handler for equivalent mosaic message at hand & call it
				boost::mutex::scoped_lock lock(callback_mutex_);
				CallbackMap::key_type key = mMessage.MessageID();
				std::string ID_temp = mMessage.MessageID();
				if (!(ID_temp == "4013" || ID_temp == "4027" || ID_temp == "4001"|| ID_temp == "5908")) 
				// We only want to handle SatVisibility, ChannelStatus, DOP and VelCovGeodetic blocks in case GPSFix messages are to be published, see few lines below.
				{
					for (CallbackMap::iterator callback = callbackmap_.lower_bound(key); callback != callbackmap_.upper_bound(key); ++callback)
					{
						try
						{
							callback->second->Handle(mMessage, callback->first);
						}
						catch (std::runtime_error& e) 
						{
							throw std::runtime_error(e.what());
						}
					}
				}
				// Call NavSatFix callback function if it was added
				if (publish_navsatfix)
				{
					CallbackMap::key_type key = "NavSatFix";
					std::string ID_temp = mMessage.MessageID();
					if (ID_temp == "4007") 	// If no new PVTGeodetic block is coming in, there is no need to publish NavSatFix anew. 
											// It would be wasteful to also call the NavSatFix handle if the PosCovGeodetic block comes in.
					{
						for (CallbackMap::iterator callback = callbackmap_.lower_bound(key); callback != callbackmap_.upper_bound(key); ++callback)
						{
							try
							{
								callback->second->Handle(mMessage, callback->first);
							}
							catch (std::runtime_error& e) 
							{
								throw std::runtime_error(e.what());
							}
						}
					}
				}
				// Call geometry_msgs::PoseWithCovarianceStamped callback function if it was added
				if (publish_posewithcovariancestamped)
				{
					CallbackMap::key_type key = "PoseWithCovarianceStamped";
					std::string ID_temp = mMessage.MessageID();
					if (ID_temp == "4007") 	// If no new PVTGeodetic block is coming in, there is no need to publish PoseWithCovarianceStamped anew. 
											// It would be wasteful to also call the PoseWithCovarianceStamped handle if the PosCovGeodetic block etc. comes in.
					{
						for (CallbackMap::iterator callback = callbackmap_.lower_bound(key); callback != callbackmap_.upper_bound(key); ++callback)
						{
							try
							{
								callback->second->Handle(mMessage, callback->first);
							}
							catch (std::runtime_error& e) 
							{
								throw std::runtime_error(e.what());
							}
						}
					}
				}
				// Call sensor_msgs::TimeReference (with GPST) callback function if it was added
				if (publish_gpst)
				{
					CallbackMap::key_type key = "GPST";
					std::string ID_temp = mMessage.MessageID();
					if (ID_temp == "4007") 	// If no new PVTGeodetic block is coming in, there is no need to publish PoseWithCovarianceStamped anew. 
											// It would be wasteful to also call the PoseWithCovarianceStamped handle if the PosCovGeodetic block etc. comes in.
					{
						for (CallbackMap::iterator callback = callbackmap_.lower_bound(key); callback != callbackmap_.upper_bound(key); ++callback)
						{
							try
							{
								callback->second->Handle(mMessage, callback->first);
							}
							catch (std::runtime_error& e) 
							{
								throw std::runtime_error(e.what());
							}
						}
					}
				}
				// Call GPSFix callback function if it was added
				if (publish_gpsfix)
				{
					CallbackMap::key_type key1 = "GPSFix";
					std::string ID_temp = mMessage.MessageID();
					if (ID_temp == "4007") 	// If no new PVTGeodetic block is coming in, there is no need to publish GPSFix anew. 
											// It would be wasteful to also call the GPSFix handle when any of the PosCovGeodetic, SatVisibility, ChannelStatus etc. blocks comes in.
					{
						for (CallbackMap::iterator callback = callbackmap_.lower_bound(key1); callback != callbackmap_.upper_bound(key1); ++callback)
						{
							try
							{
								callback->second->Handle(mMessage, callback->first);
							}
							catch (std::runtime_error& e) 
							{
								throw std::runtime_error(e.what());
							}
						}
					}
					CallbackMap::key_type key2 = mMessage.MessageID();
					if (ID_temp == "4013" || ID_temp == "4027" || ID_temp == "4001" || ID_temp == "5908") 
					// Even though we are not interested in publishing SatVisibility (4012) and ChannelStatus (4013) ROS messages, we have to save
					// some contents of these incoming blocks in order to publish the GPSFix message. When these 2 blocks come in, the unchanged GPSFix message is published anew.
					{
						for (CallbackMap::iterator callback = callbackmap_.lower_bound(key2); callback != callbackmap_.upper_bound(key2); ++callback)
						{
							try
							{
								callback->second->Handle(mMessage, callback->first);
							}
							catch (std::runtime_error& e) 
							{
								throw std::runtime_error(e.what());
							}
						}
					}
				}
			}
			
			/**
			 * @brief Searches for mosaic messages that could potentially be decoded/parsed/published  
			 * @param[in] data Buffer passed on from AsyncManager class
			 * @param[in] size Size of the buffer
			 */
			void ReadCallback(const uint8_t* data, std::size_t& size) 
			{
				mosaicMessage mMessage(data, size);
				// Read !all! (there might be many) messages in the buffer
				while (mMessage.Search() != mMessage.End() && mMessage.Found()) 
				{
					// Print the found message (if NMEA) or just show messageID (if SBF)..
					if (mMessage.IsSBF())
					{
						unsigned long sbf_block_length;
						sbf_block_length = (unsigned long) mMessage.BlockLength(); // C-like cast notation (since functional notation did not work, although https://www.cplusplus.com/doc/tutorial/typecasting/ suggests otherwise)
						ROS_DEBUG("ROSaic reading SBF block %s with %lu bytes...", mMessage.MessageID().c_str(), sbf_block_length); // Recall: The long data type is at least 32 bits.
						if (sbf_block_length < 15) // If the SBF block is so corrupted that not even its header's Length field could be properly read, don't bother to process the block, but technically not necessary here.
						{
							continue;
						}
					}
					if (mMessage.IsNMEA())
					{
						boost::char_separator<char> sep("\r");
						typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
						std::size_t nmea_size = std::min(mMessage.SegmentEnd(), static_cast<std::size_t>(89));
						std::string block_in_string(reinterpret_cast<const char*>(mMessage.Pos()), nmea_size);	// Syntax: new_string_name (const char* s, size_t n); size_t is either 2 or 8 bytes, depending on your system
						tokenizer tokens(block_in_string, sep);
						ROS_DEBUG("The NMEA message is ready to be parsed. It reads: %s", (*tokens.begin()).c_str());
					}
					if (mMessage.IsResponse())
					{
						std::size_t response_size = mMessage.SegmentEnd();
						std::string block_in_string(reinterpret_cast<const char*>(mMessage.Pos()), response_size);
						ROS_DEBUG("mosaic's response contains %li bytes and reads:\n %s", response_size, block_in_string.c_str());
						{
							boost::mutex::scoped_lock lock(response_mutex);
							response_received = true;
							lock.unlock();
							response_condition.notify_one();
						}
						if (mMessage.IsErrorMessage())
						{
							ROS_ERROR("Invalid command just sent to mosaic!");
						}
					}
					if (mMessage.IsConnectionDescriptor())
					{
						std::string cd(reinterpret_cast<const char*>(mMessage.Pos()), 4);
						mosaic_tcp_port = cd;
						ROS_INFO_COND(cd_count == 0, "The connection descriptor for the TCP connection is %s", cd.c_str());
						if (cd_count < 3) ++cd_count;
						if (cd_count == 2)
						{
							boost::mutex::scoped_lock lock(cd_mutex);
							cd_received = true;
							lock.unlock();
							cd_condition.notify_one();
						}
					}
					//ROS_DEBUG("Handing over from readcallback to Handle while count is %d", mMessage.GetCount());
					try
					{
						Handle(mMessage);
					}
					catch (std::runtime_error& e) 
					{
						ROS_DEBUG("Without a (circular) buffer and a new thread, we would have faced an incomplete message right now. %s", e.what());
						throw (static_cast<std::size_t>(mMessage.Pos() - data));
					}
				}
			}
			
			//! Callback handlers multimap for mosaic messages; it needs to be public since we copy-assign (did not work otherwise) new callbackmap_, 
			//! after inserting a pair to the multimap within the DefineMessages() method of the ROSaicNode class, onto its old version.
			CallbackMap callbackmap_;
	 
		private:
			
			//! The "static" keyword resolves construct-by-copying issues related to this mutex by making it available throughout the code. 
			//! The mutex constructor list contains "mutex (const mutex&) = delete", hence construct-by-copying a mutex is explicitly prohibited.
			static boost::mutex callback_mutex_; 
			
	};
}

#endif
