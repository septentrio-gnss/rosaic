// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************


#ifndef COMMUNICATION_CORE_HPP // This block is called a conditional group. The controlled text will get included in the preprocessor output iff the macroname is not defined
#define COMMUNICATION_CORE_HPP // include guards help to avoid the double inclusion of the septentrio.h file, by defining a token = macro

#define MAX_MSG_SIZE 4096 // See header message length, the preprocessor will replace MAX_MSG_SIZE (a macro) by 4096 (in bytes)
#define MAX_NOUT_SIZE 4096  // Maximum size of a Septentrio block in bytes (ALMANAC logs are big!)

#define SEP_SYNC_BYTE_1 0x24 //0x24 is ASCII for $ - 1st byte in each message
#define SEP_SYNC_BYTE_2 0x40 //0x24 is ASCII for @ - 2nd byte to indicate SBF block
#define SEP_SYNC_BYTE_3 0x50 //0x50 is ASCII for P - 2nd byte to indicate proprietary ASCII message
#define SEP_SYNC_BYTE_4 0x47 //0x47 is ASCII for G - 2nd byte to indicate NMEA-type ASCII message

#include <ros/ros.h>
// Boost (C++ libraries) Boost is a set of libraries for the C++ programming language that provides support for tasks and structures such as linear algebra, pseudorandom number generation, multithreading, image processing, regular expressions, and unit testing.
// Boost also allows to go beyond the long long, long double data type (which is 64 bits, usually).
#include <boost/function.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/asio.hpp>
#include <boost/exception/diagnostic_information.hpp>  // dealing with bad file descriptor error
#include <boost/bind.hpp>
#include <boost/format.hpp>
#include <boost/asio/serial_port.hpp>
#include <sstream>
#include <string.h>
#include <memory>
#include <rosaic/communication/mosaicMessage.hpp>
#include <rosaic/communication/async_manager.hpp>
#include <rosaic/communication/callbackhandlers.hpp>
#include <rosaic/crc/crc.h> // for calculating CRC checks, the crc.h file is a C style header file, hence has its declarations are in an extern C block


/**
 * @file communication_core.hpp
 * @date 22/08/20
 * @brief Highest-Level view on communication services
 */
 
/**
 * @namespace io_comm_mosaic
 * This namespace is for the communication interface, handling all aspects related to serial and TCP/IP communication..
 */
namespace io_comm_mosaic 
{
	
	extern int debug;

	// Possible baudrates for mosaic-x5
	const static uint32_t Baudrates[] = {1200, 2400, 4800, 9600, 19200, 38400, 57600, 
										115200, 230400, 460800, 500000, 576000, 921600, 
										1000000, 1152000, 1500000, 2000000, 2500000, 
										3000000, 3500000, 4000000};

	/**
	 * @class Comm_IO
	 * @brief Handles communication with and configuration of the mosaic-x5 device(s)
	 */
	class Comm_IO {
		public:
			// Sleep time in milliseconds after setting the baudrate to certain value (important between increments)
			const static int SetBaudrateSleepMs = 500;
			// Size of write buffer in bytes for output messages
			// const static int WriterSize = 2056;
	  
			/**
			* @brief Default constructor of the class Comm_IO
			*/
			Comm_IO(); //getting rid of default did not solve the issue of insert not surviving
			/**
			* @brief Default destructor of the class Comm_IO
			*/
			virtual ~Comm_IO() = default;
			
			/**
			 * @brief Initializes the serial port
			 * @param[in] port The device's port address
			 * @param[in] baudrate The chosen baud rate of the port
			 * @param[in] flowcontrol Default is "None", set variable to "RTS|CTS" to activate hardware flow control 
			 * (only for ports COM1, COM2 and COM3)
			 */
			bool InitializeSerial(std::string port, uint32_t baudrate = 115200, std::string flowcontrol = "None");
			
			/**
			 * @brief Read an NMEA message or SBF block of the given type T, e.g. PVTGeodetic
			 * 
			 * InitializeSerial is not self-contained: The for loop in Callbackhandlers' handle method would never open a specific handler unless the handler is added (=inserted) to the map via this function. 
			 * This way (since specific handle exists), the specific handler is opened, hence mosaicMessage's read method is called, "message" occupied (we allow for some time for this to happen), and func_ is called with the same, now occupied, "message", before control is handed back to bool read, which just returns true after deleting the specific handler.
			 * Outline: mosaic_node calls both InitializeSerial and e.g. bool read(GPGGA to_be_published) and then publish it!
			 * @param[out] message The received message
			 * @param[in] timeout The amount of time to wait for the desired message (before callback-handler is erased without populating message)
			 */
			template <typename T>
			bool poll(T& message, std::string message_ID, const boost::posix_time::time_duration& timeout);
									
			/**
			 * @brief Set the I/O manager
			 * @param[in] manager An I/O handler
			 */
			void setManager(const boost::shared_ptr<Manager>& manager);
			
			/**
			 * @brief Reset the Serial I/O port, e.g. after mosaic reset.
			 * @param[in] port The device's port address
			 */
			void resetSerial(std::string port);
			
			CallbackHandlers get_handlers() const {return handlers_;}
			
			//! Callback handlers for the inwards streaming messages
			CallbackHandlers handlers_;
	  
		private:
		
			//! Saves the port description
			std::string serial_port_;
			//! Processes I/O stream data
			boost::shared_ptr<Manager> manager_;
			//! Baudrate at the moment, unless InitializeSerial or ResetSerial fail
			uint32_t baudrate_;
			
			friend class CallbackHandlers;
	};
}

#endif  // for COMMUNICATION_CORE_HPP
