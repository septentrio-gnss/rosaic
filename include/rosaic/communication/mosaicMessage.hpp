// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************

//! 0x24 is ASCII for $ - 1st byte in each message
#define SEP_SYNC_BYTE_1 0x24 
//! 0x24 is ASCII for @ - 2nd byte to indicate SBF block
#define SEP_SYNC_BYTE_2 0x40 
//! 0x50 is ASCII for P - 2nd byte to indicate proprietary ASCII message
#define SEP_SYNC_BYTE_3 0x50 
//! 0x47 is ASCII for G - 2nd byte to indicate NMEA-type ASCII message
#define SEP_SYNC_BYTE_4 0x47 

#include <cstddef>
#include <sstream>
#include <boost/tokenizer.hpp>
#include <rosaic/crc/crc.h> // for calculating CRC checks, the crc.h file is a C style header file, hence has its declarations are in an extern C block
#include <rosaic/parsers/string_utilities.h>
#include <rosaic/parsers/nmea_sentence.hpp>
#include <nmea_msgs/Gpgga.h>
#include <rosaic/parsers/nmea_parsers/gpgga.hpp>
#include <map>
#include <ros/ros.h>
#include <boost/call_traits.hpp>
#include <rosaic/PVTCartesian.h>
#include <rosaic/PVTGeodetic.h>
#include <boost/format.hpp>

#ifndef MOSAIC_MESSAGE_HPP
#define MOSAIC_MESSAGE_HPP

/**
 * @file mosaicMessage.hpp
 * @date 20/08/20
 * @brief Defines a class that can deal with a buffer of size bytes_transferred that is handed over from async_read_some
 */
 
extern bool use_GNSS_time;
extern uint32_t read_count;
//! Since switch only works with int (yet NMEA message IDs are strings), we need enum.
//! Note drawbacks: No variable can have a name which is already in some enumeration, enums are not type safe etc..
enum NMEA_ID_Enum {evGPGGA};
//! Static keyword makes them visible only to the code of this particular .cpp file (and those that import it), which helps to avoid global namespace pollution.
//! One also receives "multiple definition of 'StringValues'" without the static keyword.
static std::map<std::string, NMEA_ID_Enum> StringValues;
static void StringValues_Initialize()
{
	StringValues.insert(std::make_pair("$GPGGA", evGPGGA));
}
  
namespace io_comm_mosaic 
{
	
	/**
	 * @brief Callback function when reading PVTCartesian blocks
	 * @param[in] data The (packed and aligned) struct instance that we use to populate our ROS message rosaic::PVTCartesian
	 * @return A smart pointer to the ROS message rosaic::PVTCartesian just created
	 */
	rosaic::PVTCartesianPtr PVTCartesianCallback(PVTCartesian& data);
	
	/**
	 * @brief Callback function when reading PVTCartesian blocks
	 * @param[in] data The (packed and aligned) struct instance that we use to populate our ROS message rosaic::PVTCartesian
	 * @return A smart pointer to the ROS message rosaic::PVTCartesian just created
	 */
	rosaic::PVTGeodeticPtr PVTGeodeticCallback(PVTGeodetic& data);
	
	/**
	 * @brief Calculates the timestamp, in the Unix Epoch time format, either using the TOW as transmitted with the SBF block, or using the current time
	 * @param[in] TOW Number of milliseconds that elapsed since the beginning of the current GPS week as transmitted by the SBF block
	 * @param[in] use_GNSS_time If true, the TOW as transmitted with the SBF block is used, otherwise the current time
	 * @return ros::Time object containing seconds and nanoseconds since last epoch
	 */
	ros::Time timestampSBF(uint32_t TOW, bool use_GNSS);
	
	/**
	 * @class mosaicMessage
	 * @brief Can search buffer for messages, jump to next one (in case of SBF block), and so on
	 */
	class mosaicMessage
	{
	public:
			/**
			 * @brief Constructor of the mosaicMessage class
			 * @param[out] data Pointer to the buffer that is about to be analyzed
			 * @param[in] size Size of the buffer (as handed over by async_read_some)
			 */
			mosaicMessage(const uint8_t* data, std::size_t& size): data_(data), count_(size) {}
			// One can always provide a non-const value where a const one was expected. The const-ness of the argument just means the function promises not to change it..
			// Recall: static_cast by the way can remove or add const-ness, no other C++ cast is capable of removing it (not even reinterpret_cast)
			
			//! Calculates the CRC of the SBF block where data_ is pointing to at the moment
			bool checksum();
			//! Determines whether data_ points to the SBF block with ID "ID", e.g. 5003
			bool isMessage(const uint16_t ID);
			//! Determines whether data_ points to the NMEA message with ID "ID", e.g. "$GPGGA"
			bool isMessage(std::string ID);
			//! Returns the MessageID of the message where data_ is pointing at at the moment, SBF identifiers embellished with inverted commas, e.g. "5003"
			std::string MessageID(); 
			
			int8_t get_count() {return count_;};
			/**
			 * @brief Searches the buffer for the beginning of the next message (NMEA or SBF)
			 * @return A pointer to the start of the next message.
			*/
			const uint8_t* search();
			
			/**
			 * @brief Gets the length of the SBF block
			 *
			 * It determines the length from the header of the SBF block and thus includes the header length.
			 * @return The length of the SBF block
			 */
			uint16_t block_length();
			
			/**
			 * @brief Gets the current position in the read buffer
			 * @return The current position of the read buffer
			 */
			const uint8_t* pos();
			
			/**
			 * @brief Gets the end position in the read buffer
			 * @return A pointer pointing to just after the read buffer (matches search()'s pointer if no valid message is found)
			 */
			const uint8_t* end();
		  
			/**
			 * @brief Has an NMEA message or SBF block been found in the buffer?
			 * @returns True if a message with the correct header & length has been found.
			 */
			bool found();
			
			/**
			 * @brief Goes to the start of the next message based on the calculated length of current message
			 */
			const uint8_t* next();
			
			/**
			 * @brief Performs CRC check (if SBF block) and populates message with the necessary content (mapped 1-to-1 if SBF, parsed if NMEA), works for pure ROS message mapping.
			 * @return True if read was successful, false otherwise
			 */
			template <typename T>
			bool read(typename boost::call_traits<T>::reference message, bool search = false); 
			
		private:

			/**
			 * @brief The pointer to the buffer of messages
			 */
			const uint8_t* data_; 
			
			/**
			 * @brief The number of bytes in the buffer, decremented as the buffer is read (so it is the buffer's size in the beginning)
			 */
			uint32_t count_; 
			
			/**
			 * @brief The checksum that is calculated when bool checksum() is called is stored here.
			 */
			uint16_t checksum_;
			
			/**
			 * @brief Whether or not a message has been found
			 */
			bool found_; 
			
	};
	
	
	/**
	 * Note: Will have to think about what to do in the more complex case (e.g. for GPSFix, we need to store values SBF blocks to wait for others)..
	 * Note that boost::call_traits<T>::reference is more robust than traditional T&.
	 * Note that this function also assigns the appropriate derived parser in case T is an NMEA message.
	 * Note that putting the default in the definition's argument list instead of the declaration's is an added extra that is not available for function templates, hence no search = false here.
	 * Finally note that it is bad practice (I got undefined reference to .. error) to separate the definition of template functions into the source file and declarations into header file. I guess another
	 * solution would be to add explicit instantiations into the mosaicMessage.cpp file.
	 * Also note that the SBF block header part of the SBF-echoing ROS messages have ID fields that only show the block number as found in the firmware (e.g. 4007 for PVTGeodetic), without the revision number.
	 */
	template <typename T>
	bool mosaicMessage::read(typename boost::call_traits<T>::reference message, bool search) 
	{
		//ROS_DEBUG("Inside mosaicMessage's read");
		if (search) this->search();
		if (!found()) return false; 
		if (data_[0] == SEP_SYNC_BYTE_1 && data_[1] == SEP_SYNC_BYTE_2)
		{
			// CRC Check
			bool CRCcheck = CRCIsValid(data_);
			if (!CRCcheck)
			{
				std::stringstream ss;
				ss << "CRC Check returned False. Not a valid data block, perhaps noisy. Ignore..";
				throw std::runtime_error(ss.str().c_str());
			}
			uint32_t SBF_ID;
			string_utilities::ToUInt32(this->MessageID(), SBF_ID);
			switch(SBF_ID) 
			{
				// Position and velocity in XYZ
				case 4006:
				{ 	// The curly bracket here is crucial: declarations inside a block remain inside, and will die at the end of the block
					rosaic::PVTCartesianPtr msg = boost::make_shared<rosaic::PVTCartesian>();
					PVTCartesian pvt_cartesian;
					ROS_DEBUG("sizeof(pvt_object) is %u", (uint16_t) (sizeof(pvt_cartesian)));
					memcpy(&pvt_cartesian, data_, sizeof(pvt_cartesian));
					msg = PVTCartesianCallback(pvt_cartesian);
					msg->ROS_Header.seq = read_count;
					msg->ROS_Header.frame_id = frame_id;
					uint32_t TOW = *(reinterpret_cast<const uint32_t *>(data_ + 8));
					ros::Time time_obj;
					time_obj = timestampSBF(TOW, use_GNSS_time);
					msg->ROS_Header.stamp.sec = time_obj.sec;
					msg->ROS_Header.stamp.nsec = time_obj.nsec;
					msg->Block_Header.ID = 4006;
					memcpy(&message, msg.get(), sizeof(*msg));
					++read_count;
					break;
				}
				
				// Position and velocity in geodetic coordinate frame (ENU frame)
				case 4007:
				{ 	// The curly bracket here is crucial: declarations inside a block remain inside, and will die at the end of the block
					rosaic::PVTGeodeticPtr msg = boost::make_shared<rosaic::PVTGeodetic>();
					PVTGeodetic pvt_geodetic;
					ROS_DEBUG("sizeof(pvt_object) is %u", (uint16_t) (sizeof(pvt_geodetic)));
					memcpy(&pvt_geodetic, data_, sizeof(pvt_geodetic));
					msg = PVTGeodeticCallback(pvt_geodetic);
					msg->ROS_Header.seq = read_count;
					msg->ROS_Header.frame_id = frame_id;
					uint32_t TOW = *(reinterpret_cast<const uint32_t *>(data_ + 8));
					ros::Time time_obj;
					time_obj = timestampSBF(TOW, use_GNSS_time);
					msg->ROS_Header.stamp.sec = time_obj.sec;
					msg->ROS_Header.stamp.nsec = time_obj.nsec;
					msg->Block_Header.ID = 4007;
					memcpy(&message, msg.get(), sizeof(*msg));
					++read_count;
					break;
				}

				// Position Covariance block
				case 5905:
				{
					memcpy(&message, data_+8, sizeof(message));
					break;
				}
				// many more to be implemented...
			}
		}
		else
		{
			boost::char_separator<char> sep("*");
			typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
			std::size_t end_point = std::min(static_cast<std::size_t>(this->end() - data_), static_cast<std::size_t>(82));
			std::string block_in_string(reinterpret_cast<const char*>(data_), end_point);
			tokenizer tokens(block_in_string, sep);
			ROS_DEBUG("NMEA message is %s", (*tokens.begin()).c_str());
			switch(StringValues[this->MessageID()])
			{
				case evGPGGA:
				{
					std::string id = this->MessageID();
					std::string pure_block = *tokens.begin();
					boost::char_separator<char> sep_2(",", "", boost::keep_empty_tokens);
					tokenizer tokens_2(pure_block, sep_2);
					std::vector<std::string> body;
					for (tokenizer::iterator tok_iter = tokens_2.begin(); tok_iter != tokens_2.end(); ++tok_iter) // perhaps str.erase from <string.h> would be faster, but i would not know what exactly to do..
					{
						body.push_back(*tok_iter);
					}
					// Create NmeaSentence struct to pass to GpggaParser::ParseASCII
					rosaic_driver::NMEASentence gga_message(id, body);
					nmea_msgs::GpggaPtr gpgga_ros_message_ptr;
					rosaic_driver::GpggaParser parser_obj;
					try
					{
						gpgga_ros_message_ptr = parser_obj.ParseASCII(gga_message);
					}
					catch (rosaic_driver::ParseException& e)
					{
						ROS_INFO("GGA parsing failed: %s\n", e.what());
						throw std::runtime_error(e.what());
					}
					memcpy(&message, gpgga_ros_message_ptr.get(), sizeof(*gpgga_ros_message_ptr));
					return true;
				}
			}
		}
		return true;
	}
}

#endif // for MOSAIC_MESSAGE_HPP


