// *****************************************************************************
//
// Â© Copyright 2020, Septentrio NV/SA.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//    1. Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//    3. Neither the name of the copyright holder nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE 
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE. 
//
// *****************************************************************************

// *****************************************************************************
//
// Boost Software License - Version 1.0 - August 17th, 2003
// 
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// *****************************************************************************

//! 0x24 is ASCII for $ - 1st byte in each message
#define SEP_SYNC_BYTE_1 0x24 
//! 0x24 is ASCII for @ - 2nd byte to indicate SBF block
#define SEP_SYNC_BYTE_2 0x40 
//! 0x50 is ASCII for P - 2nd byte to indicate proprietary ASCII message
#define SEP_SYNC_BYTE_3 0x50 
//! 0x47 is ASCII for G - 2nd byte to indicate NMEA-type ASCII message
#define SEP_SYNC_BYTE_4 0x47 

#include <cstddef>
#include <boost/tokenizer.hpp>
#include <sstream>
#include <rosaic/crc/crc.h> // for calculating CRC checks, the crc.h file is a C style header file, hence has its declarations are in an extern C block
#include <rosaic/parsers/string_utilities.h>
#include <rosaic/parsers/nmea_sentence.hpp>
#include <nmea_msgs/Gpgga.h>
#include <rosaic/parsers/nmea_parsers/gpgga.hpp>
#include <map>
#include <ros/ros.h>
#include <boost/call_traits.hpp>

#ifndef MOSAIC_MESSAGE_HPP
#define MOSAIC_MESSAGE_HPP

/**
 * @file mosaicMessage.hpp
 * @date 20/08/20
 * @brief Defines a class that can deal with a buffer of size bytes_transferred that is handed over from async_read_some
 */
 
//! Since switch only works with int (yet NMEA message IDs are strings), we need enum.
//! Note drawbacks: No variable can have a name which is already in some enumeration, enums are not type safe etc..
enum NMEA_ID_Enum {evGPGGA};
//! Static keyword makes them visible only to the code of this particular .cpp file (and those that import it), which helps to avoid global namespace pollution.
//! One also receives "multiple definition of 'StringValues'" without the static keyword.
static std::map<std::string, NMEA_ID_Enum> StringValues;
static void StringValues_Initialize()
{
	StringValues.insert(std::make_pair("$GPGGA", evGPGGA));
}
  
namespace io_comm_mosaic 
{
	/**
	 * @class mosaicMessage
	 * @brief Can search buffer for messages, jump to next one (in case of SBF block), and so on
	 */
	class mosaicMessage
	{
	public:
			/**
			 * @brief Constructor of the mosaicMessage class
			 * @param[out] data Pointer to the buffer that is about to be analyzed
			 * @param[in] size Size of the buffer (as handed over by async_read_some)
			 */
			mosaicMessage(const uint8_t* data, std::size_t& size): data_(data), count_(size) {}
			// One can always provide a non-const value where a const one was expected. The const-ness of the argument just means the function promises not to change it..
			// Recall: static_cast by the way can remove or add const-ness, no other C++ cast is capable of removing it (not even reinterpret_cast)
			
			//! Calculates the CRC of the SBF block where data_ is pointing to at the moment
			bool checksum();
			//! Determines whether data_ points to the SBF block with ID "ID", e.g. 5003
			bool isMessage(const uint16_t ID);
			//! Determines whether data_ points to the NMEA message with ID "ID", e.g. "$GPGGA"
			bool isMessage(std::string ID);
			//! Returns the MessageID of the message where data_ is pointing at at the moment, SBF identifiers embellished with inverted commas, e.g. "5003"
			std::string MessageID(); 
			
			int8_t get_count() {return count_;};
			/**
			 * @brief Searches the buffer for the beginning of the next message (NMEA or SBF)
			 * @return A pointer to the start of the next message.
			*/
			const uint8_t* search();
			
			/**
			 * @brief Gets the length of the SBF block
			 *
			 * It determines the length from the header of the SBF block and thus includes the header length.
			 * @return The length of the SBF block
			 */
			uint32_t block_length();
			
			/**
			 * @brief Gets the current position in the read buffer
			 * @return The current position of the read buffer
			 */
			const uint8_t* pos();
			
			/**
			 * @brief Gets the end position in the read buffer
			 * @return A pointer pointing to just after the read buffer (matches search()'s pointer if no valid message is found)
			 */
			const uint8_t* end();
		  
			/**
			 * @brief Has an NMEA message or SBF block been found in the buffer?
			 * @returns True if a message with the correct header & length has been found.
			 */
			bool found();
			
			/**
			 * @brief Goes to the start of the next message based on the calculated length of current message
			 */
			const uint8_t* next();
			
			/**
			 * @brief Performs CRC check (if SBF block) and populates message with the necessary content (mapped 1-to-1 if SBF, parsed if NMEA), works for pure ROS message mapping.
			 * @return True if read was successful, false otherwise
			 */
			template <typename T>
			bool read(typename boost::call_traits<T>::reference message, bool search = false); 
			
		private:

			/**
			 * @brief The pointer to the buffer of messages
			 */
			const uint8_t* data_; 
			
			/**
			 * @brief The number of bytes in the buffer, decremented as the buffer is read (so it is the buffer's size in the beginning)
			 */
			uint32_t count_; 
			
			/**
			 * @brief The checksum that is calculated when bool checksum() is called is stored here.
			 */
			uint16_t checksum_;
			
			/**
			 * @brief Whether or not a message has been found
			 */
			bool found_; 
	};
	
	
	/**
	 * Note: Will have to think about what to do in the more complex case (e.g. for GPSFix, we need to store values SBF blocks to wait for others)..
	 * Note that boost::call_traits<T>::reference is more robust than traditional T&.
	 * Note that this function also assigns the appropriate derived parser in case T is an NMEA message.
	 * Note that putting the default in the definition's argument list instead of the declaration's is an added extra that is not available for function templates, hence no search = false here.
	 * Finally note that it is bad practice (I got undefined reference to .. error) to separate the definition of template functions into the source file and declarations into header file. I guess another
	 * solution would be to add explicit instantiations into the mosaicMessage.cpp file.
	 */
	template <typename T>
	bool mosaicMessage::read(typename boost::call_traits<T>::reference message, bool search) 
	{
		//ROS_DEBUG("Inside mosaicMessage's read");
		if (search) this->search();
		if (!found()) return false; 
		if (data_[1] == SEP_SYNC_BYTE_2)
		{
			// CRC Check
			bool CRCcheck = CRCIsValid(data_);
			if (!CRCcheck)
			{
				ROS_DEBUG("CRC Check returned False for SBF block %s. Not a valid data block, perhaps noisy. Move on to next message/block of buffer..", this->MessageID().c_str());
				return false;
			}
			uint32_t SBF_ID;
			string_utilities::ToUInt32(this->MessageID(), SBF_ID);
			switch(SBF_ID) 
			{
				// Postion and velocity in XYZ
				case 4006:
					memcpy(&message, data_+8, sizeof(message)); // you cut out the block you are interested in via sizeof(..) since you do not care about the header of the block..
					// read_timestamp... Caution: This should be part of Septentrio::readSerialPort(), since you want the timestamp when message came in, not after all these calculations...
					// now do message.GPS_ms for instance
					break;

				// Position Covariance block
				case 5905:
					memcpy(&message, data_+8, sizeof(message));
					break;
				// many more to be implemented...
			}
		}
		else
		{
			boost::char_separator<char> sep("*");
			typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
			std::size_t end_point = std::min(static_cast<std::size_t>(this->end() - data_), static_cast<std::size_t>(82));
			std::string block_in_string(reinterpret_cast<const char*>(data_), end_point);		// We cannot uses overloaded '=' operator from string class since that converts char* to string 
			// Instead, reinterpret_cast<char*>(name) casts from uint8_t* to char* in an unsafe way but that's the one which should be used here. Then you call the ordinary constructor of std::string
			tokenizer tokens(block_in_string, sep);
			ROS_DEBUG("NMEA message is %s", (*tokens.begin()).c_str());
			// typeid (explointing knowledge about T) instead of switch with message ID would not quite work (e.g. gcc gives you mangled names for instance), and even boost's fancy names are not that fancy..
			switch(StringValues[this->MessageID()])
			{
				case evGPGGA:
					std::string id = this->MessageID();
					std::string pure_block = *tokens.begin();
					boost::char_separator<char> sep_2(",", "", boost::keep_empty_tokens);
					tokenizer tokens_2(pure_block, sep_2);
					std::vector<std::string> body;
					for (tokenizer::iterator tok_iter = tokens_2.begin(); tok_iter != tokens_2.end(); ++tok_iter) // perhaps str.erase from <string.h> would be faster, but i would not know what exactly to do..
					{
						// create NmeaSentence struct to pass to GpggaParser::ParseAscii
						body.push_back(*tok_iter);
					}
					rosaic_driver::NMEASentence gga_message(id, body);
					//ROS_DEBUG("First entry of vector is %s", body[0].c_str());
					// Pass NmeaSentence struct to GGA-Parser
					nmea_msgs::GpggaPtr gpgga_ros_message_ptr;
					rosaic_driver::GpggaParser parser_obj;
					try
					{
						gpgga_ros_message_ptr = parser_obj.ParseASCII(gga_message);
					}
					catch (rosaic_driver::ParseException& e)
					{
						std::cout << "GGA parsing failed: " << e.what() << "\n";
					}
					message = *gpgga_ros_message_ptr; 
					return true;
			}
		}
		return true;
	}
}

#endif // for MOSAIC_MESSAGE_HPP


